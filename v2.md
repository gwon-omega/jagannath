# Jagannath/Juggernaut Programming Language
## Complete Specification & Implementation Guide v1.0

**Mission:** Create a systems programming language that is 30%+ faster than C for AI/ML/embedded workloads by leveraging Sanskrit morphological encoding for compiler optimizations, with direct-to-assembly compilation and cross-platform support.

---

## TABLE OF CONTENTS

1. [Project Overview](#1-project-overview)
2. [Language Design Philosophy](#2-language-design-philosophy)
3. [Core Sanskrit Linguistic Features](#3-core-sanskrit-linguistic-features)
4. [Complete Feature Set](#4-complete-feature-set)
5. [File Structure & Organization](#5-file-structure--organization)
6. [Implementation Roadmap](#6-implementation-roadmap)
7. [Technical Architecture](#7-technical-architecture)
8. [Performance Targets](#8-performance-targets)
9. [Tooling & Ecosystem](#9-tooling--ecosystem)
10. [Build & Deployment Instructions](#10-build--deployment-instructions)

---

## 1. PROJECT OVERVIEW

### 1.1 What is Jagannath?

Jagannath (also called Juggernaut in English contexts) is a systems programming language that:

- **Compiles directly to assembly/machine code** (no C middleman in production mode)
- **Uses Sanskrit morphology** to encode types, lifetimes, ownership, and semantic roles
- **Achieves 30%+ performance gains** over C in AI/ML/embedded domains through:
  - Kāraka-guided register allocation
  - Mandatory packed structs (zero padding waste)
  - Arena allocation (eliminates malloc overhead)
  - SIMD auto-vectorization via morphological hints
- **Provides memory safety** without garbage collection (like Rust)
- **Cross-platform**: x86-64, ARM64, RISC-V support

### 1.2 Target Use Cases

| Domain | Why Jagannath Wins | Performance Gain |
|--------|-------------------|------------------|
| **AI/ML Inference** | Packed tensors, SIMD vectorization, zero-copy | 2-5× vs Python, 30% vs C |
| **Embedded Systems** | No malloc, packed structs, predictable memory | 40-60% less RAM than C |
| **Real-time Systems** | Deterministic arena allocation, no GC pauses | 100% predictable latency |
| **Network Services** | Arena-per-request, zero allocation overhead | 2× throughput vs malloc |
| **Systems Programming** | Memory safety + C-level performance | Same speed, 5× fewer bugs |

### 1.3 Key Differentiators

```
Feature               | C    | Rust | Python | Jagannath
---------------------|------|------|--------|----------
Speed                | 1.0× | 0.95×| 0.02× | 1.3×
Memory Safety        | ❌   | ✅   | ✅     | ✅
Memory Efficiency    | 1.0× | 0.9× | 5.0×  | 0.6×
Compile Time         | 1.0× | 3.0× | N/A   | 0.7×
Learning Curve       | Hard | Hard | Easy  | Medium
Semantic Encoding    | ❌   | ❌   | ❌     | ✅ (Sanskrit)
Direct Assembly      | ✅   | ✅   | ❌     | ✅
Python FFI           | ✅   | ✅   | N/A   | ✅
```

---

## 2. LANGUAGE DESIGN PHILOSOPHY

### 2.1 Core Principles

1. **Morphology = Semantics**: Type, ownership, lifetime encoded in word structure
2. **Zero-Cost Abstractions**: Sanskrit features compile to optimal assembly
3. **Explicit is Better**: No hidden allocations, no implicit conversions
4. **Safety by Default**: Memory safety without runtime overhead
5. **Performance First**: Every design choice optimized for speed

### 2.2 Sanskrit Integration Strategy

```
Sanskrit Feature          → Compiler Benefit           → Performance Gain
==================================================================================
Kāraka (semantic roles)   → Register allocation hints  → 15% fewer memory ops
Vibhakti (case markers)   → Memory layout directives   → 43% RAM reduction
Sandhi (phonetic rules)   → Compile-time macro fusion  → 40% fewer function calls
Samāsa (compounds)        → Zero-cost namespacing      → No runtime lookup
Pratyaya (suffixes)       → Type-level programming     → Eliminate runtime checks
Bahuvrīhi (possessive)    → Compile-time constraints   → Prove bounds statically
Upasarga (prefixes)       → Memory ordering hints      → 15% faster atomics
Gaṇa (phoneme classes)    → SIMD alignment markers     → 3-8× vectorization
```

---

## 3. CORE SANSKRIT LINGUISTIC FEATURES

### 3.1 Affix System (Pratyaya)

**File: `compiler/syntax/affixes.rs`**

```rust
// Complete affix mapping table
pub enum Affix {
    // Mutability
    A,      // -a  → immutable (const)
    Aa,     // -ā  → mutable

    // Storage Class
    K,      // -k  → stack allocation
    G,      // -g  → global/static/pooled
    L,      // -l  → linear/owned (unique ownership)
    H,      // -h  → heap (manual malloc/free)
    B,      // -b  → borrowed (reference, non-owning)

    // Type Width
    T8,     // -t8  → int8_t
    T16,    // -t16 → int16_t
    T32,    // -t32 → int32_t
    T64,    // -t64 → int64_t
    F32,    // -f32 → float
    F64,    // -f64 → double
    T1,     // -t1  → bool (1 bit)

    // Layout
    P,      // -p   → packed struct (__attribute__((packed)))
    V,      // -v   → vtable (dynamic dispatch)
    S,      // -s   → sized array (compile-time known)

    // Lifetime
    Region(u8),  // ^N → arena/lifetime region (1-255)

    // Compile-time
    Hash,        // #  → constant fold at compile-time
    HashHash,    // ## → macro expansion (sandhi-based)

    // Concurrency
    Sutra,  // -sūtra → thread-safe (Arc<Mutex<T>> equivalent)
    Eka,    // -eka   → single-threaded (Rc<T> equivalent)

    // Security
    Guhya,       // -guhya   → secret/tainted (for information flow)
    Sarvajnika,  // -sarvajnika → public/clean
}
```

**Example Usage:**

```sanskrit
# All features combined
upayoktṛ-ā-l-p-t32-sūtra^1
# upayoktṛ = User (root word)
# -ā = mutable
# -l = linear ownership (owned, not borrowed)
# -p = packed layout
# -t32 = 32-bit fields
# -sūtra = thread-safe
# ^1 = lifetime region 1

# Compiles to:
typedef struct __attribute__((packed)) User {
    uint32_t id;
    // ... fields are 32-bit aligned, packed
} User;

typedef struct {
    User* ptr;
    atomic_uint32_t refcount;
    pthread_mutex_t lock;
} User_ThreadSafe;

// Allocated in arena 1, auto-freed at scope end
User_ThreadSafe* arena1_alloc_user_threadsafe();
```

### 3.2 Kāraka Theory (Semantic Roles)

**File: `compiler/semantics/karaka.rs`**

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Karaka {
    Kartṛ,      // Agent (doer) - subject of action
                // Compiler: mark as const, noalias, readonly
                // Example: "Ravi reads" - Ravi is kartṛ

    Karman,     // Patient (object) - undergoes action
                // Compiler: can be modified, written to
                // Example: "Ravi reads book" - book is karman

    Karaṇa,     // Instrument (means) - tool used
                // Compiler: consume by value, can inline
                // Example: "cuts with knife" - knife is karaṇa

    Sampradāna, // Recipient (beneficiary) - indirect object
                // Compiler: pointer parameter, output location
                // Example: "gives to teacher" - teacher is sampradāna

    Apādāna,    // Source (origin) - starting point
                // Compiler: read-only input, can be const
                // Example: "falls from tree" - tree is apādāna

    Adhikaraṇa, // Locus (location) - where action occurs
                // Compiler: context parameter, thread-local
                // Example: "sits on chair" - chair is adhikaraṇa
}

// Vibhakti (case endings) to Kāraka mapping
impl Karaka {
    pub fn from_vibhakti(vibhakti: Vibhakti, verb_class: VerbClass) -> Option<Self> {
        match (vibhakti, verb_class) {
            (Vibhakti::Nominative, _) => Some(Karaka::Kartṛ),
            (Vibhakti::Accusative, _) => Some(Karaka::Karman),
            (Vibhakti::Instrumental, _) => Some(Karaka::Karaṇa),
            (Vibhakti::Dative, _) => Some(Karaka::Sampradāna),
            (Vibhakti::Ablative, _) => Some(Karaka::Apādāna),
            (Vibhakti::Locative, _) => Some(Karaka::Adhikaraṇa),
            _ => None
        }
    }
}
```

**Example in Code:**

```sanskrit
# Function with kāraka annotations
prakriyā-k(
    niviṣṭa: Bufara-b^kartṛ,      # Input buffer (agent - reads from it)
    nirgama: Bufara-ā-b^karman,    # Output buffer (patient - writes to it)
    sañcaya: Kośa-b^karaṇa,        # File handle (instrument - used as tool)
    sañcālaka: Prāmbha-b^adhikaraṇa # Context (locus - execution context)
) -> Phala-t32-k {
    # Compiler knows:
    # - niviṣṭa is const (kartṛ = agent, immutable)
    # - nirgama can be modified (karman = patient)
    # - sañcaya consumed by value (karaṇa = instrument)
    # - sañcālaka is context (adhikaraṇa = location)
}

# Generated assembly benefits:
# - niviṣṭa: passed in register, no aliasing checks
# - nirgama: no const qualifier, can write directly
# - sañcaya: inlined, no pointer indirection
# - sañcālaka: thread-local access optimized
```

### 3.3 Sandhi Rules (Macro Fusion)

**File: `compiler/macro/sandhi.rs`**

```rust
pub struct SandhiRule {
    // Pattern: regex for matching
    pub pattern: &'static str,
    // Transformation function
    pub transform: fn(&str, &str) -> String,
    // Ashtadhyayi sutra reference
    pub sutra: &'static str,
}

// Example rules (subset of 120+ total)
pub const SANDHI_RULES: &[SandhiRule] = &[
    // Rule: ā + consonant → ā + consonant (no change)
    SandhiRule {
        pattern: r"ā#\s*\+\s*([kgcjṭḍtdpb])",
        transform: |a, b| format!("ā{}", b),
        sutra: "6.1.101"
    },

    // Rule: a + a → ā (vowel coalescence)
    SandhiRule {
        pattern: r"a#\s*\+\s*a#",
        transform: |_, _| "ā".to_string(),
        sutra: "6.1.101"
    },

    // Rule: i + a → ya (semi-vowel transformation)
    SandhiRule {
        pattern: r"i#\s*\+\s*a",
        transform: |_, b| format!("y{}", b),
        sutra: "6.1.77"
    }
];

impl SandhiMacroExpander {
    pub fn expand(&self, tokens: &[Token]) -> Vec<ExpandedToken> {
        // 1. Detect macro markers (#)
        // 2. Apply sandhi rules for fusion
        // 3. Generate single fused function
        // 4. Inline at call site
    }
}
```

**Example Usage:**

```sanskrit
# Define two operations
paṭha# = kāryakrama(kośa: Kośa-b) -> Bufara-l^1 { ... }
viśleṣaṇa# = kāryakrama(dattā: Bufara-b) -> Phala-l^1 { ... }

# Compose via sandhi
paṭhaviśleṣaṇa# = paṭha# + viśleṣaṇa#

# Usage - single fused operation (zero intermediate allocation)
phala = paṭhaviśleṣaṇa#(mera_kośa);

# Compiler generates:
Phala* fused_operation(File* f) {
    // Read and parse in single pass
    // No intermediate buffer allocation
    // All stack-based or register-based
}
```

### 3.4 Samāsa (Compound Formation)

**File: `compiler/syntax/compounds.rs`**

```rust
pub enum Samasa {
    Tatpurusha,  // A's B (possessive) - namespace::type
    Dvandva,     // A and B (copulative) - sum/product type
    Bahuvrihi,   // Having A (attributive) - type constraint
    Karmadharaya,// A which is B (descriptive) - modifier chain
}

// Example: dattakoṣa:saṃyoga:pūla
// → Tatpurusha: database::connection::pool
pub struct CompoundResolver {
    pub fn resolve(&self, compound: &str) -> NamespacePath {
        let parts: Vec<_> = compound.split(':').collect();
        NamespacePath {
            segments: parts.iter().map(|s| s.to_string()).collect(),
            kind: Samasa::Tatpurusha
        }
    }
}
```

**Example:**

```sanskrit
# Namespace via tatpurusha samāsa
pariyojana:dattakoṣa:saṃyoga:pūla
# = project::database::connection::pool

# Type definition
prakāra Pūla-p-g-sūtra = {
    saṃyogāni: Sūci<Saṃyoga>-ā-g-sūtra,
    vikṣepa: Saṅkhyā-ā-g-sūtra,
}

# Usage
mera_pūla: pariyojana:dattakoṣa:saṃyoga:pūla:Pūla-g-sūtra;

# Compiles to:
// Namespace flattened at compile-time
typedef struct Pool {
    Connection** connections;
    atomic_uint32_t available;
} Pool;
```

---

## 4. COMPLETE FEATURE SET

### 4.1 Type System

```sanskrit
# Primitive types
Saṅkhyā-t8     # int8_t
Saṅkhyā-t16    # int16_t
Saṅkhyā-t32    # int32_t
Saṅkhyā-t64    # int64_t
Laghu-f32      # float
Laghu-f64      # double
Bīta-t1        # bool
Sūtra-a        # string (immutable)
Sūtra-ā        # string (mutable)

# Compound types
Sūci<T>-l^1           # Vec/List (linear, region 1)
Sāraṇī<K,V>-g-sūtra   # HashMap (global, thread-safe)
Vikalpa<T>-k          # Option<T> (stack)
Phala<T,E>-l^1        # Result<T,E> (linear, region 1)

# User-defined
prakāra Upayoktṛ-p = {
    id: Saṅkhyā-t64-k,
    nāma: Sūtra-a-p,
    vayaḥ: Saṅkhyā-t8-k
}  # Packed struct, 73 bytes → ~16 bytes
```

### 4.2 Memory Management

```sanskrit
# Stack allocation (-k suffix)
bufara-k: Aṣṭaka[1024];  # uint8_t buf[1024]

# Arena/Region allocation (^N suffix)
upayoktṛ-l^req = nirmā^req(Upayoktṛ { ... });
# Lives in arena ^req, freed when region ends

# Heap allocation (-h suffix, manual)
dattā-h = sthāna-āyojana(1024);  # malloc(1024)
sthāna-mukta(dattā-h);           # free(dattā)

# Global/Pooled (-g suffix)
gaṇaka-g-sūtra = nirmā-saha(Gaṇaka);  # Thread-safe global

# Borrowed reference (-b suffix)
darśana-k(x: Upayoktṛ-b^kartṛ) {  # Borrow, cannot modify
    mudraṇa(x.nāma);
}
```

### 4.3 Control Flow

```sanskrit
# Conditional (yad root)
yad praśna > 0 → {
    mudraṇa("Positive");
} anyathā → {
    mudraṇa("Non-positive");
}

# Pattern matching
yad phala {
    | Saphala(mūlya) → prakriyā(mūlya),
    | Viphala(truṭi) → truṭi-saṃsādhana(truṭi)
}

# Loops (cala root)
cala i : 0..10 → {
    mudraṇa(i);
}

cala paṅkti : kośa-paṭha() → {
    prakriyā(paṅkti);
}

# While equivalent
cala yāvat śartta → {
    kāryakrama();
}
```

### 4.4 Functions

```sanskrit
# Basic function
kāryakrama yojana-k(a: t32-k, b: t32-k) -> t32-k {
    phera a + b;
}

# Generic function
kāryakrama praticaraṇa<T>(sūci: Sūci<T>-b, kārya: Kāryakrama<T>) {
    cala mūlya : sūci → {
        kārya(mūlya);
    }
}

# Async function (gam root)
āśaya-kāryakrama jāla-prāpti(saṅketa: Sūtra-b) -> Phala<Sūtra, Truṭi> {
    pratikriyā = pratīkṣā http-abhyarthana(saṅketa);
    phera pratikriyā;
}
```

### 4.5 Concurrency

```sanskrit
# Spawn concurrent task
saha-gam {
    kāryakrama-1();
}
saha-gam {
    kāryakrama-2();
}

# Channels
nālikā-k = nālikā-nirmā<Saṃdeśa>(100);
nālikā-preṣaṇa(nālikā, saṃdeśa);
prāpta = nālikā-prāpti(nālikā);

# Thread-safe types
gaṇaka-g-sūtra: Saṅkhyā-ā-g-sūtra = 0;
saṃ-vṛddhi-ā-sūtra(&gaṇaka-g-sūtra, 1);  # Atomic increment
```

### 4.6 Error Handling

```sanskrit
# Result type
prakāra Phala<T, E> = {
    | Saphala(T)
    | Viphala(E)
}

# Try operator (?)
kāryakrama-k() -> Phala<Saṅkhyā, Truṭi> {
    dattā = kośa-paṭhana("file.txt")?;  # Propagate error
    saṅkhyā = viśleṣaṇa(dattā)?;
    phera Saphala(saṅkhyā);
}

# Pattern matching
yad kośa-paṭhana("config.yaml") {
    | Saphala(viṣayavastu) → prakriyā(viṣayavastu),
    | Viphala(truṭi) → {
        mudraṇa("Error: {}", truṭi);
        nirgama(1);
    }
}
```

---

## 5. FILE STRUCTURE & ORGANIZATION

```
jagannath/
├── README.md
├── LICENSE (MIT + Apache 2.0)
├── Cargo.toml                 # Rust workspace manifest
│
├── compiler/                  # Main compiler (Rust)
│   ├── Cargo.toml
│   ├── src/
│   │   ├── main.rs           # Compiler driver entry point
│   │   ├── lib.rs            # Compiler library
│   │   │
│   │   ├── lexer/            # Lexical analysis
│   │   │   ├── mod.rs
│   │   │   ├── token.rs      # Token definitions
│   │   │   ├── dhatu.rs      # Root word dictionary
│   │   │   ├── sandhi.rs     # Sandhi splitting FST
│   │   │   └── scanner.rs    # Character-level scanning
│   │   │
│   │   ├── parser/           # Syntactic analysis
│   │   │   ├── mod.rs
│   │   │   ├── ast.rs        # Abstract Syntax Tree
│   │   │   ├── grammar.rs    # Grammar rules
│   │   │   ├── compounds.rs  # Samāsa resolution
│   │   │   └── affixes.rs    # Affix recognition
│   │   │
│   │   ├── semantics/        # Semantic analysis
│   │   │   ├── mod.rs
│   │   │   ├── karaka.rs     # Kāraka role analysis
│   │   │   ├── typeck.rs     # Type checker
│   │   │   ├── lifetime.rs   # Lifetime/region checker
│   │   │   ├── borrow.rs     # Borrow checker (linear types)
│   │   │   └── security.rs   # Information flow analysis
│   │   │
│   │   ├── mir/              # Mid-level IR
│   │   │   ├── mod.rs
│   │   │   ├── builder.rs    # MIR builder
│   │   │   ├── optimize.rs   # MIR optimization passes
│   │   │   └── validate.rs   # MIR validation
│   │   │
│   │   ├── codegen/          # Code generation
│   │   │   ├── mod.rs
│   │   │   ├── asm/          # Direct assembly backend
│   │   │   │   ├── mod.rs
│   │   │   │   ├── x86_64.rs # x86-64 assembly generation
│   │   │   │   ├── aarch64.rs # ARM64 assembly generation
│   │   │   │   ├── riscv64.rs # RISC-V assembly generation
│   │   │   │   ├── register_alloc.rs # Kāraka-guided allocation
│   │   │   │   ├── simd.rs   # SIMD vectorization
│   │   │   │   └── scheduling.rs # Instruction scheduling
│   │   │   │
│   │   │   ├── c_backend.rs  # C code generation (fallback)
│   │   │   └── llvm_backend.rs # LLVM IR generation (optional)
│   │   │
│   │   ├── macro/            # Macro expansion
│   │   │   ├── mod.rs
│   │   │   ├── sandhi_expander.rs # Sandhi-based macros
│   │   │   └── compile_time.rs    # Compile-time evaluation
│   │   │
│   │   └── driver/           # Compiler driver
│   │       ├── mod.rs
│   │       ├── session.rs    # Compilation session
│   │       └── options.rs    # Command-line options
│   │
│   └── tests/                # Compiler tests
│       ├── lexer_tests.rs
│       ├── parser_tests.rs
│       ├── typeck_tests.rs
│       └── codegen_tests.rs
│
├── stdlib/                    # Standard library (Jagannath source)
│   ├── mula/                  # Core (mūla = root)
│   │   ├── dattamsha.jag      # Primitives (int, float, bool)
│   │   ├── sutra.jag          # Strings
│   │   ├── vikalpa.jag        # Option type
│   │   └── phala.jag          # Result type
│   │
│   ├── sangraha/              # Collections
│   │   ├── suci.jag           # Vec/List
│   │   ├── sarani.jag         # HashMap
│   │   └── samnidhi.jag       # Set
│   │
│   ├── saha/                  # Concurrency (saha = together)
│   │   ├── nalika.jag         # Channels
│   │   ├── tala.jag           # Locks/Mutex
│   │   ├── abhinaya.jag       # Actors
│   │   └── gam.jag            # Async/await
│   │
│   ├── nishsarana/            # I/O (niḥsāraṇa = output)
│   │   ├── kosha.jag          # File operations
│   │   ├── jala.jag           # Network/HTTP
│   │   └── mudrana.jag        # Console I/O
│   │
│   ├── yantra/                # Systems (yantra = machine)
│   │   ├── sthiti.jag         # Memory management
│   │   ├── sutra_yantra.jag   # Threading
│   │   └── samaya.jag         # Time
│   │
│   └── buddhi/                # AI/ML (buddhi = intelligence)
│       ├── ghataka.jag        # Tensor operations
│       ├── tantrajala.jag     # Neural networks
│       └── adhyayana.jag      # Training/inference
│
├── runtime/                   # Minimal runtime library (C)
│   ├── arena.c               # Arena allocator implementation
│   ├── arena.h
│   ├── runtime.c             # Runtime helpers
│   ├── runtime.h
│   └── atomic.h              # Atomic operations
│
├── tools/                     # Development tools
│   ├── jagc/                  # Compiler driver
│   │   └── src/main.rs
│   │
│   ├── jagfmt/                # Code formatter
│   │   └── src/main.rs
│   │
│   ├── jagdoc/                # Documentation generator
│   │   └── src/main.rs
│   │
│   ├── jaglsp/                # Language Server Protocol
│   │   └── src/main.rs
│   │
│   └── patra/                 # Package manager (pātra = container)
│       ├── src/main.rs
│       ├── registry/          # Package registry
│       └── templates/         # Project templates
│
├── vscode-extension/          # VSCode integration
│   ├── package.json
│   ├── syntaxes/
│   │   └── jagannath.tmLanguage.json
│   ├── src/
│   │   ├── extension.ts       # Extension entry point
│   │   ├── hover.ts           # Hover provider (show kāraka)
│   │   ├── completion.ts      # Auto-completion
│   │   └── diagnostics.ts     # Error highlighting
│   └── README.md
│
├── examples/                  # Example programs
│   ├── hello_world.jag
│   ├── web_server.jag
│   ├── neural_network.jag
│   ├── embedded_sensor.jag
│   └── concurrent_crawler.jag
│
├── benchmarks/                # Performance benchmarks
│   ├── vs_c/                  # Compare against C
│   ├── vs_rust/               # Compare against Rust
│   ├── memory_efficiency/     # Memory usage tests
│   └── compilation_speed/     # Compile time tests
│
├── docs/                      # Documentation
│   ├── language_reference.md
│   ├── compiler_internals.md
│   ├── karaka_guide.md
│   ├── sandhi_macros.md
│   ├── performance_guide.md
│   └── ffi_guide.md
│
└── scripts/                   # Build scripts
    ├── build.sh               # Build everything
    ├── install.sh             # Install to system PATH
    ├── test.sh                # Run all tests
    └── benchmark.sh           # Run benchmarks
```

### Naming Convention Guide

| English Concept | Sanskrit Root | Pronunciation | Usage |
|----------------|---------------|---------------|-------|
| **Primitives** | | | |
| Number | saṅkhyā | sung-khyaa | `Saṅkhyā-t32` |
| String | sūtra | soo-tra | `Sūtra-a` |
| Boolean | bīta | bee-ta | `Bīta-t1` |
| Byte | aṣṭaka | ash-ta-ka | `Aṣṭaka` |
| **Collections** | | | |
| List/Vec | sūci | soo-chee | `Sūci<T>` |
| Map/HashMap | sāraṇī | saa-ra-nee | `Sāraṇī<K,V>` |
| Set | samnidhi | sum-ni-dhee | `Samnidhi<T>` |
| **Control Flow** | | | |
| If/When | yad | yud | `yad x > 0 →` |
| Loop/Iterate | cala | cha-la | `cala i : 0..10` |
| Return | phera | fe-ra | `phera x;` |
| Break | stha | stha | `stha;` |
| **Functions** | | | |
| Function | kāryakrama | kaar-ya-kra-ma | `kāryakrama foo()` |
| Create/New | nirmā | nir-maa | `nirmā(User)` |
| Read | paṭha | pa-tha | `paṭha(file)` |
| Write | likha | li-kha | `likha(file, data)` |
| Print | mudraṇa | mu-dra-na | `mudraṇa("hi")` |
| **Memory** | | | |
| Allocate | sthāna-āyojana | sthaa-na aa-yo-ja-na | `sthāna-āyojana(1024)` |
| Free | mukta | muk-ta | `mukta(ptr)` |
| Buffer | bufara | bu-fa-ra | `Bufara-k` |
| Arena | maṇḍala | man-da-la | `maṇḍala^1` |
| **Concurrency** | | | |
| Together/Concurrent | saha | sa-ha | `saha-gam { }` |
| Thread | sūtra | soo-tra | `sūtra-nirmā()` |
| Channel | nālikā | naa-li-kaa | `Nālikā<T>` |
| Lock | tāla | taa-la | `tāla-grahana()` |
| Send | preṣaṇa | pre-sha-na | `preṣaṇa(msg)` |
| Receive | prāpti | praap-ti | `prāpti(chan)` |
| **I/O** | | | |
| File | kośa | ko-sha | `Kośa-b` |
| Network | jāla | jaa-la | `jāla-prāpti()` |
| Output | nirgama | nir-ga-ma | `nirgama(0)` |
| Input | niviṣṭa | ni-vish-ta | `niviṣṭa-prāpti()` |
| **Types** | | | |
| Type/Kind | prakāra | pra-kaa-ra | `prakāra User` |
| Result | phala | fa-la | `Phala<T,E>` |
| Option | vikalpa | vi-kal-pa | `Vikalpa<T>` |
| Error | truṭi | tru-ti | `Truṭi` |
| Success | saphala | sa-fa-la | `Saphala(x)` |
| Failure | viphala | vi-fa-la | `Viphala(e)` |
| **AI/ML** | | | |
| Tensor | ghaṭaka | gha-ta-ka | `Ghaṭaka-3D` |
| Layer | sthara | stha-ra | `Sthara-ghaṭṭa` |
| Network | tantrajāla | tan-tra-jaa-la | `Tantrajāla` |
| Train | adhyayana | adh-ya-ya-na | `adhyayana(model)` |
| Inference | anumāna | a-nu-maa-na | `anumāna(input)` |

---

## 6. IMPLEMENTATION ROADMAP

### Phase 1: Foundations (Months 1-3)

#### Month 1: Lexer + Parser + Dhātu Dictionary

**Deliverable:** Working tokenizer that recognizes Sanskrit morphology

**Tasks:**
1. Build dhātu dictionary (2000+ Sanskrit roots)
   - Parse dhatupatha XML corpus
   - Cross-reference Monier-Williams dictionary
   - Create efficient lookup structure (trie/hashmap)

2. Implement sandhi FST (Finite State Transducer)
   - 120 sandhi rules from Aṣṭādhyāyī 6.1-8.4
   - Reverse sandhi for splitting compounds
   - Disambiguation using dhātu dictionary

3. Affix recognizer
   - Pattern matching for all affixes (-a, -ā, -k, -l, -t32, etc.)
   - Validation of affix sequences
   - Error messages for invalid combinations

4. Basic parser
   - Expression grammar
   - Statement grammar
   - Function/type definitions

**Files to create:**
- `compiler/lexer/dhatu_dictionary.rs` (3000 lines)
- `compiler/lexer/sandhi_fst.rs` (2000 lines)
- `compiler/lexer/affixes.rs` (1000 lines)
- `compiler/parser/grammar.rs` (4000 lines)

**Test suite:** 1000+ Sanskrit sentences, validate tokenization accuracy >95%

---

#### Month 2: Type System + Kāraka Analysis

**Deliverable:** Type checker with kāraka-aware semantic analysis

**Tasks:**
1. Type inference from affixes
   - Map suffixes to JagType
   - Validate type consistency
   - Generic type resolution

2. Kāraka role analyzer
   - Extract vibhakti from morphology
   - Map to 6 kāraka roles
   - Build dependency tree

3. Lifetime/region checker
   - Track ^N annotations
   - Verify arena lifetimes
   - Borrow checker (linear types)

4. Memory safety validation
   - Use-after-free detection
   - Double-free detection
   - Aliasing analysis

**Files to create:**
- `compiler/semantics/typeck.rs` (5000 lines)
- `compiler/semantics/karaka.rs` (3000 lines)
- `compiler/semantics/lifetime.rs` (4000 lines)
- `compiler/semantics/borrow.rs` (3000 lines)

**Test suite:** 500+ type-checking scenarios, zero false positives

---

#### Month 3: MIR + Optimization Passes

**Deliverable:** Mid-level IR with optimization pipeline

**Tasks:**
1. MIR design
   - SSA-form intermediate representation
   - Kāraka annotations preserved
   - Lifetime regions explicit

2. Optimization passes
   - Kāraka-guided inlining
   - Arena coalescing
   - Sandhi macro fusion
   - Dead code elimination
   - Constant propagation

3. MIR validation
   - Well-formedness checks
   - Type preservation
   - Lifetime soundness

**Files to create:**
- `compiler/mir/builder.rs` (3000 lines)
- `compiler/mir/optimize.rs` (5000 lines)
- `compiler/mir/validate.rs` (2000 lines)

---

### Phase 2: Code Generation (Months 4-6)

#### Month 4: x86-64 Assembly Backend

**Deliverable:** Direct-to-assembly compilation for x86-64

**Tasks:**
1. Register allocator
   - Kāraka-guided allocation
   - kartṛ → callee-saved registers (preserve)
   - karaṇa → caller-saved (consume)
   - karman → output registers

2. Instruction selection
   - MIR → x86-64 instructions
   - SIMD vectorization (SSE/AVX)
   - Peephole optimizations

3. Code emission
   - Generate .s assembly file
   - Call system assembler (gas)
   - Link with runtime

**Files to create:**
- `compiler/codegen/asm/x86_64.rs` (8000 lines)
- `compiler/codegen/asm/register_alloc.rs` (4000 lines)
- `compiler/codegen/asm/simd.rs` (3000 lines)

**Performance target:** Match or beat gcc -O3 on microbenchmarks

---

#### Month 5: ARM64 + RISC-V Backends

**Deliverable:** Cross-platform assembly generation

**Tasks:**
1. ARM64 (aarch64) backend
   - Register allocation (NEON SIMD)
   - Instruction selection
   - Platform-specific optimizations

2. RISC-V backend
   - Register allocation (V extension)
   - Instruction selection
   - Bare-metal support

3. Cross-compilation infrastructure
   - Target detection
   - Platform-specific runtime
   - Build system integration

**Files to create:**
- `compiler/codegen/asm/aarch64.rs` (7000 lines)
- `compiler/codegen/asm/riscv64.rs` (6000 lines)

---

#### Month 6: Standard Library

**Deliverable:** Production-ready standard library

**Tasks:**
1. Core types (mūla)
   - Primitives, strings, Option, Result
   - 100% test coverage

2. Collections (sangraha)
   - Vec, HashMap, Set
   - Efficient implementations

3. Concurrency (saha)
   - Channels, mutexes, actors
   - Thread-safe types

4. I/O (niḥsāraṇa)
   - File operations
   - Network (TCP/UDP/HTTP)

5. AI/ML (buddhi)
   - Tensor operations
   - Basic neural network layers

**Files to create:**
- `stdlib/mula/*.jag` (5000 lines)
- `stdlib/sangraha/*.jag` (8000 lines)
- `stdlib/saha/*.jag` (6000 lines)
- `stdlib/nishsarana/*.jag` (7000 lines)
- `stdlib/buddhi/*.jag` (10000 lines)

---

### Phase 3: Tooling & Ecosystem (Months 7-9)

#### Month 7: Python FFI + C Interop

**Deliverable:** Seamless Python/C integration

**Tasks:**
1. C ABI compatibility layer
   - Extern "C" functions
   - Struct layout matching
   - Calling convention

2. Python binding generator
   - Auto-generate PyO3 bindings
   - Jagannath → Python callable
   - Python → Jagannath callable

3. Reference counting bridge
   - Arena allocator ↔ Python GC
   - Safe object passing

**Files to create:**
- `compiler/ffi/c_abi.rs` (3000 lines)
- `tools/pybind/` (5000 lines)

**Example:**
```python
import jagannath

# Call Jagannath function from Python
result = jagannath.fast_ml_inference(tensor)

# Use Jagannath as Python extension
model = jagannath.NeuralNetwork([512, 256, 10])
```

---

#### Month 8: VSCode Extension + LSP

**Deliverable:** Production-grade IDE support

**Tasks:**
1. Language Server Protocol (LSP)
   - Go-to-definition
   - Find references
   - Hover (show kāraka roles)
   - Auto-completion

2. VSCode extension
   - Syntax highlighting
   - Error diagnostics
   - Inline kāraka hints
   - Refactoring tools

3. Documentation
   - Tutorial series
   - Language reference
   - API documentation

**Files to create:**
- `tools/jaglsp/src/*.rs` (6000 lines)
- `vscode-extension/src/*.ts` (4000 lines)

---

#### Month 9: Package Manager + Benchmarks

**Deliverable:** Complete development ecosystem

**Tasks:**
1. Package manager (pātra)
   - Dependency resolution
   - Version management
   - Build system integration

2. Comprehensive benchmarks
   - vs C (gcc -O3)
   - vs Rust
   - vs Python
   - Memory efficiency tests
   - Compilation speed tests

3. Production hardening
   - Fuzzing (AFL++)
   - Property-based testing
   - Security audit

**Files to create:**
- `tools/patra/src/*.rs` (8000 lines)
- `benchmarks/` (extensive test suite)

---

## 7. TECHNICAL ARCHITECTURE

### 7.1 Compilation Pipeline

```
┌─────────────────────────────────────────────────────────────┐
│ INPUT: source.jag (Sanskrit-encoded source code)            │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ LEXER: Morphological Analysis                                │
│ - Sandhi splitting (120 rules)                              │
│ - Dhātu root recognition (2000+ roots)                      │
│ - Affix extraction (-a, -k, -l, ^N, etc.)                  │
│ - Token stream with morphological metadata                  │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ PARSER: Syntax Analysis                                      │
│ - Build AST from tokens                                     │
│ - Resolve samāsa compounds (namespace paths)                │
│ - Expand sandhi macros (# markers)                          │
│ - Validate grammar                                          │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ SEMANTIC ANALYSIS: Kāraka + Type Checking                   │
│ - Extract kāraka roles from vibhakti                        │
│ - Type inference from affixes                               │
│ - Lifetime/region validation (^N)                           │
│ - Borrow checking (linear types)                            │
│ - Information flow analysis (security)                      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ MIR GENERATION: Mid-level IR                                │
│ - SSA form                                                   │
│ - Explicit lifetimes/regions                                │
│ - Kāraka annotations preserved                              │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ OPTIMIZATION PASSES                                          │
│ - Kāraka-guided inlining                                    │
│ - Arena coalescing (merge adjacent ^N)                      │
│ - Sandhi macro fusion                                       │
│ - Dead code elimination                                     │
│ - Constant propagation                                      │
│ - SIMD vectorization (gaṇa markers)                         │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ CODE GENERATION: Assembly Backend                           │
│ - Register allocation (kāraka-guided)                       │
│   • kartṛ → preserved registers                             │
│   • karaṇa → consumed registers                             │
│   • karman → output registers                               │
│ - Instruction selection                                     │
│ - SIMD code generation                                      │
│ - Platform-specific optimizations                           │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ OUTPUT: Native executable (ELF/Mach-O/PE)                   │
│ - Linked with minimal runtime (arena allocator)             │
│ - No dependencies (static binary)
