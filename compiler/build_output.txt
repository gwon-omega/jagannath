warning: unused import: `std::fmt`
  --> compiler\src\errors\rich_report.rs:29:5
   |
29 | use std::fmt;
   |     ^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `crate::parser::ast::Identifier`
 --> compiler\src\parser\compounds.rs:9:5
  |
9 | use crate::parser::ast::Identifier;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `AffixSequence`
  --> compiler\src\semantics\borrow.rs:17:27
   |
17 | use crate::lexer::{Affix, AffixSequence, Span};
   |                           ^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> compiler\src\semantics\generics.rs:29:33
   |
29 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused imports: `FunctionDef`, `GenericParam`, `Identifier`, and `TypeDef`
  --> compiler\src\semantics\generics.rs:33:33
   |
33 | use crate::parser::ast::{Block, FunctionDef, GenericParam, Identifier, Type, TypeDef};
   |                                 ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^        ^^^^^^^

warning: unused import: `TraitRef`
  --> compiler\src\semantics\generics.rs:34:53
   |
34 | use crate::semantics::traits::{TraitBound, TraitId, TraitRef};
   |                                                     ^^^^^^^^

warning: unused import: `self`
 --> compiler\src\semantics\karaka.rs:8:26
  |
8 | use crate::parser::ast::{self, Karaka, Parameter, FunctionDef};
  |                          ^^^^

warning: unused imports: `AffixSequence` and `Affix`
  --> compiler\src\semantics\lifetime.rs:17:20
   |
17 | use crate::lexer::{Affix, AffixSequence, Span};
   |                    ^^^^^  ^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> compiler\src\semantics\lifetime.rs:19:33
   |
19 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused imports: `KarakaAnalyzer` and `TypeChecker`
 --> compiler\src\semantics\philosophy_integration.rs:5:13
  |
5 | use super::{TypeChecker, KarakaAnalyzer};
  |             ^^^^^^^^^^^  ^^^^^^^^^^^^^^

warning: unused import: `super::pramana::Pramana`
  --> compiler\src\semantics\typeck\lifetimes.rs:40:5
   |
40 | use super::pramana::Pramana;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `TypeInfo`
  --> compiler\src\semantics\typeck\lifetimes.rs:41:34
   |
41 | use super::types::{ResolvedType, TypeInfo, TypeVar};
   |                                  ^^^^^^^^

warning: unused imports: `Instruction`, `MemoryRef`, `Operand`, `RegisterKind`, and `Register`
  --> compiler\src\codegen\asm\x86_64.rs:19:25
   |
19 | use super::{AsmEmitter, Instruction, MemoryRef, Operand, Register, RegisterKind};
   |                         ^^^^^^^^^^^  ^^^^^^^^^  ^^^^^^^  ^^^^^^^^  ^^^^^^^^^^^^

warning: unused imports: `FloatSize`, `IntSize`, and `MirType`
  --> compiler\src\codegen\asm\x86_64.rs:21:40
   |
21 |     BinaryOp, FloatBinaryOp, FloatCmp, FloatSize, IntSize, MirConstant, MirFunction,
   |                                        ^^^^^^^^^  ^^^^^^^
22 |     MirInstruction, MirOperand, MirPlace, MirRvalue, MirTerminator, MirType, PlaceProjection,
   |                                                                     ^^^^^^^

warning: unused imports: `Instruction`, `Operand`, `RegisterKind`, and `Register`
  --> compiler\src\codegen\asm\aarch64.rs:19:25
   |
19 | use super::{AsmEmitter, Instruction, Operand, Register, RegisterKind};
   |                         ^^^^^^^^^^^  ^^^^^^^  ^^^^^^^^  ^^^^^^^^^^^^

warning: unused import: `PlaceProjection`
  --> compiler\src\codegen\asm\aarch64.rs:22:41
   |
22 |     MirPlace, MirRvalue, MirTerminator, PlaceProjection, RegisterClass, SimdOp, SimdWidth, UnaryOp,
   |                                         ^^^^^^^^^^^^^^^

warning: unused imports: `Instruction`, `Operand`, `RegisterKind`, and `Register`
  --> compiler\src\codegen\asm\riscv64.rs:19:25
   |
19 | use super::{AsmEmitter, Instruction, Operand, Register, RegisterKind};
   |                         ^^^^^^^^^^^  ^^^^^^^  ^^^^^^^^  ^^^^^^^^^^^^

warning: unused imports: `PlaceProjection`, `SimdOp`, and `SimdWidth`
  --> compiler\src\codegen\asm\riscv64.rs:22:41
   |
22 |     MirPlace, MirRvalue, MirTerminator, PlaceProjection, RegisterClass, SimdOp, SimdWidth, UnaryOp,
   |                                         ^^^^^^^^^^^^^^^                 ^^^^^^  ^^^^^^^^^

warning: unused imports: `KarakaHint`, `MirBasicBlock`, and `MirPlace`
  --> compiler\src\codegen\regalloc.rs:15:5
   |
15 |     KarakaHint, MirBasicBlock, MirFunction, MirInstruction, MirOperand, MirPlace, MirRvalue,
   |     ^^^^^^^^^^  ^^^^^^^^^^^^^                                           ^^^^^^^^

warning: unused import: `VecDeque`
  --> compiler\src\mir\nll.rs:21:42
   |
21 | use std::collections::{HashMap, HashSet, VecDeque};
   |                                          ^^^^^^^^

warning: unused import: `crate::parser::ast::Type`
  --> compiler\src\philosophy\nyaya\pratyaksha.rs:12:5
   |
12 | use crate::parser::ast::Type;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `AllocationHandle`
  --> compiler\src\philosophy\advaita\brahman_memory.rs:10:13
   |
10 | use super::{AllocationHandle, RegionKind};
   |             ^^^^^^^^^^^^^^^^

warning: unused import: `std::any::TypeId`
  --> compiler\src\philosophy\advaita\maya_overlay.rs:15:5
   |
15 | use std::any::TypeId;
   |     ^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler\src\tantra\sri_yantra.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler\src\yoga\ashtanga\niyama.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::lexer::token::Span`
 --> compiler\src\garuda\narakas\asipatravana.rs:7:5
  |
7 | use crate::lexer::token::Span;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `BinaryOp`
 --> compiler\src\garuda\narakas\asipatravana.rs:8:75
  |
8 | use crate::parser::ast::{Ast, Expr, Item, Stmt, Block, Literal, LoopKind, BinaryOp};
  |                                                                           ^^^^^^^^

warning: unused import: `LoopKind`
 --> compiler\src\garuda\narakas\kalasutra.rs:8:50
  |
8 | use crate::parser::ast::{Ast, Block, Expr, Item, LoopKind, Stmt};
  |                                                  ^^^^^^^^

warning: unused import: `crate::errors::Span`
 --> compiler\src\garuda\narakas\krimibhaksha.rs:7:5
  |
7 | use crate::errors::Span;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `MatchArm`
 --> compiler\src\garuda\narakas\kumbhipaka.rs:8:69
  |
8 | use crate::parser::ast::{Ast, Block, Expr, Item, Literal, LoopKind, MatchArm, Stmt};
  |                                                                     ^^^^^^^^

warning: unused import: `crate::errors::Span`
 --> compiler\src\garuda\narakas\lalabhaksha.rs:7:5
  |
7 | use crate::errors::Span;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::errors::Span`
 --> compiler\src\garuda\narakas\maharaurava.rs:8:5
  |
8 | use crate::errors::Span;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::errors::Span`
 --> compiler\src\garuda\narakas\paryavartana.rs:7:5
  |
7 | use crate::errors::Span;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::errors::Span`
 --> compiler\src\garuda\narakas\puyoda.rs:7:5
  |
7 | use crate::errors::Span;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::errors::Span`
 --> compiler\src\garuda\narakas\sukaramukha.rs:7:5
  |
7 | use crate::errors::Span;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::errors::Span`
 --> compiler\src\garuda\narakas\sulaprota.rs:7:5
  |
7 | use crate::errors::Span;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Identifier`
  --> compiler\src\garuda\preta\detector.rs:23:57
   |
23 | use crate::parser::ast::{Ast, Block, Expr, FunctionDef, Identifier, Item, Stmt};
   |                                                         ^^^^^^^^^^

warning: unused import: `TaintLevel`
  --> compiler\src\garuda\vaitarani\boundary.rs:20:13
   |
20 | use super::{TaintLevel, VaitaraniViolation};
   |             ^^^^^^^^^^

warning: unused import: `crate::lexer::token::Span`
  --> compiler\src\garuda\vaitarani\boundary.rs:22:5
   |
22 | use crate::lexer::token::Span;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Identifier`
  --> compiler\src\garuda\vaitarani\boundary.rs:23:57
   |
23 | use crate::parser::ast::{Ast, Block, Expr, FunctionDef, Identifier, Item, Stmt};
   |                                                         ^^^^^^^^^^

warning: unused import: `super::TaintLevel`
 --> compiler\src\garuda\vaitarani\purification.rs:5:5
  |
5 | use super::TaintLevel;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `crate::garuda::chitragupta::ChitraguptaRecords`
 --> compiler\src\garuda\yama\dharmaraja.rs:8:5
  |
8 | use crate::garuda::chitragupta::ChitraguptaRecords;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::errors::Span`
  --> compiler\src\garuda\mod.rs:34:5
   |
34 | use crate::errors::Span;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `MirPlace`, `MirType`, `SimdOp`, and `SimdWidth`
  --> compiler\src\margas\bhakti.rs:14:92
   |
14 | ..., MirTerminator, MirRvalue, MirOperand, MirType, PlaceProjection, SimdOp, SimdWidth, MirPlace, MirConstant};
   |                                            ^^^^^^^                   ^^^^^^  ^^^^^^^^^  ^^^^^^^^

warning: unused import: `HashSet`
  --> compiler\src\margas\bhakti.rs:15:33
   |
15 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `IntSize`
  --> compiler\src\margas\jnana.rs:14:124
   |
14 | use crate::mir::types::{MirFunction, MirInstruction, MirTerminator, MirRvalue, MirOperand, MirConstant, BinaryOp, UnaryOp, IntSize};
   |                                                                                                                            ^^^^^^^

warning: unused imports: `MirBasicBlock` and `MirPlace`
  --> compiler\src\margas\karma.rs:14:92
   |
14 | use crate::mir::types::{MirFunction, MirInstruction, MirTerminator, MirRvalue, MirOperand, MirPlace, BinaryOp, MirBasicBlock};
   |                                                                                            ^^^^^^^^            ^^^^^^^^^^^^^

warning: unused import: `super::*`
   --> compiler\src\modules\resolver.rs:359:9
    |
359 |     use super::*;
    |         ^^^^^^^^

warning: unused imports: `FunctionDef` and `TypeDef`
  --> compiler\src\modules\symbol.rs:17:32
   |
17 | use crate::parser::ast::{Type, FunctionDef, TypeDef};
   |                                ^^^^^^^^^^^  ^^^^^^^

warning: unused imports: `Symbol` and `TypeSymbol`
  --> compiler\src\modules\typeck_integration.rs:24:21
   |
24 | use super::symbol::{Symbol, SymbolKind, SymbolTable, FunctionSymbol, TypeSymbol, TypeKind};
   |                     ^^^^^^                                           ^^^^^^^^^^

warning: unused import: `Identifier`
  --> compiler\src\modules\mod.rs:36:31
   |
36 | use crate::parser::ast::{Ast, Identifier, ImportStmt, Item};
   |                               ^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler\src\modules\mod.rs:37:5
   |
37 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CONTINUE`
 --> compiler\src\visitor\ast_visitor.rs:7:26
  |
7 | use super::{VisitResult, CONTINUE};
  |                          ^^^^^^^^

warning: unused import: `std::time::Instant`
  --> compiler\src\driver\philosophy_integration.rs:13:5
   |
13 | use std::time::Instant;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::philosophy::samkhya::SamkhyaPipeline`
  --> compiler\src\driver\philosophy_integration.rs:20:5
   |
20 | use crate::philosophy::samkhya::SamkhyaPipeline;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Anga`
  --> compiler\src\driver\philosophy_integration.rs:23:29
   |
23 | use crate::yoga::ashtanga::{Anga, AshtangaLifecycle};
   |                             ^^^^

warning: unused import: `LinkOutput`
 --> compiler\src\driver\session.rs:8:45
  |
8 | use crate::codegen::linker::{BuildPipeline, LinkOutput};
  |                                             ^^^^^^^^^^

warning: unused import: `Tattva`
  --> compiler\src\driver\session.rs:10:51
   |
10 | use crate::philosophy::samkhya::{SamkhyaPipeline, Tattva};
   |                                                   ^^^^^^

warning: unused import: `Path`
  --> compiler\src\driver\session.rs:11:17
   |
11 | use std::path::{Path, PathBuf};
   |                 ^^^^

warning: unused import: `crate::lexer::Lexer`
  --> compiler\src\driver\mod.rs:19:5
   |
19 | use crate::lexer::Lexer;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `MirBuilder` and `MirOptimizer`
  --> compiler\src\driver\mod.rs:20:18
   |
20 | use crate::mir::{MirBuilder, MirOptimizer};
   |                  ^^^^^^^^^^  ^^^^^^^^^^^^

warning: unused import: `crate::parser::Parser`
  --> compiler\src\driver\mod.rs:21:5
   |
21 | use crate::parser::Parser;
   |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::philosophy::guna::GunaOptimizer`
  --> compiler\src\driver\mod.rs:22:5
   |
22 | use crate::philosophy::guna::GunaOptimizer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::philosophy::kala::Kala`
  --> compiler\src\driver\mod.rs:23:5
   |
23 | use crate::philosophy::kala::Kala;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::philosophy::samkhya::SamkhyaPipeline`
  --> compiler\src\driver\mod.rs:24:5
   |
24 | use crate::philosophy::samkhya::SamkhyaPipeline;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `BorrowChecker`, `KarakaAnalyzer`, `LifetimeChecker`, and `TypeChecker`
  --> compiler\src\driver\mod.rs:25:24
   |
25 | use crate::semantics::{BorrowChecker, KarakaAnalyzer, LifetimeChecker, TypeChecker};
   |                        ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `Diagnostic`
 --> compiler\src\diagnostics\sink.rs:9:30
  |
9 | use super::{BoxedDiagnostic, Diagnostic, GunaLevel};
  |                              ^^^^^^^^^^

warning: unused variable: `ty`
   --> compiler\src\semantics\generics.rs:805:46
    |
805 |                 TypeConstraint::Implements { ty, trait_id, span } => {
    |                                              ^^ help: try ignoring the field: `ty: _`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `trait_id`
   --> compiler\src\semantics\generics.rs:805:50
    |
805 |                 TypeConstraint::Implements { ty, trait_id, span } => {
    |                                                  ^^^^^^^^ help: try ignoring the field: `trait_id: _`

warning: unused variable: `span`
   --> compiler\src\semantics\generics.rs:805:60
    |
805 |                 TypeConstraint::Implements { ty, trait_id, span } => {
    |                                                            ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `bounds`
   --> compiler\src\semantics\generics.rs:813:48
    |
813 |                 TypeConstraint::Bounded { var, bounds, span } => {
    |                                                ^^^^^^ help: try ignoring the field: `bounds: _`

warning: unused variable: `span`
   --> compiler\src\semantics\generics.rs:813:56
    |
813 |                 TypeConstraint::Bounded { var, bounds, span } => {
    |                                                        ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `type_var`
   --> compiler\src\semantics\generics.rs:815:33
    |
815 |                     if let Some(type_var) = self.context.get_by_id(var) {
    |                                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_type_var`

warning: variable does not need to be mutable
   --> compiler\src\semantics\lifetime.rs:162:13
    |
162 |         let mut lifetime_params = HashMap::new();
    |             ----^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `options`
  --> compiler\src\semantics\philosophy_integration.rs:33:25
   |
33 |     pub fn from_options(options: &crate::driver::options::CompilerOptions) -> Self {
   |                         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_options`

warning: unused variable: `env_vars`
   --> compiler\src\semantics\typeck_impl.rs:453:45
    |
453 |     fn generalize(&self, ty: &ResolvedType, env_vars: &[TypeVar]) -> ResolvedType {
    |                                             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_env_vars`

warning: unused variable: `e`
   --> compiler\src\semantics\typeck_impl.rs:686:20
    |
686 |         if let Err(e) = self.inference.unify(&body_type, &expected_return) {
    |                    ^ help: if this is intentional, prefix it with an underscore: `_e`

warning: unused variable: `span`
   --> compiler\src\semantics\typeck_impl.rs:775:35
    |
775 |             Stmt::Return { value, span } => {
    |                                   ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `span`
   --> compiler\src\semantics\typeck_impl.rs:821:17
    |
821 |                 span,
    |                 ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `end_type`
   --> compiler\src\semantics\typeck_impl.rs:887:29
    |
887 |                         let end_type = self.infer_expr(end);
    |                             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_end_type`

warning: unused variable: `left`
    --> compiler\src\semantics\typeck_impl.rs:1600:17
     |
1600 |                 left,
     |                 ^^^^ help: try ignoring the field: `left: _`

warning: unused variable: `right`
    --> compiler\src\semantics\typeck_impl.rs:1601:17
     |
1601 |                 right,
     |                 ^^^^^ help: try ignoring the field: `right: _`

warning: unused variable: `trait_name`
   --> compiler\src\semantics\typeck\constraints.rs:485:17
    |
485 |                 trait_name,
    |                 ^^^^^^^^^^ help: try ignoring the field: `trait_name: _`

warning: unused variable: `trait_name`
   --> compiler\src\semantics\typeck\constraints.rs:503:17
    |
503 |                 trait_name,
    |                 ^^^^^^^^^^ help: try ignoring the field: `trait_name: _`

warning: unused variable: `assoc_name`
   --> compiler\src\semantics\typeck\constraints.rs:504:17
    |
504 |                 assoc_name,
    |                 ^^^^^^^^^^ help: try ignoring the field: `assoc_name: _`

warning: unused variable: `resolved_expected`
   --> compiler\src\semantics\typeck\constraints.rs:509:21
    |
509 |                 let resolved_expected = self.apply(expected_type);
    |                     ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_resolved_expected`

warning: variable does not need to be mutable
   --> compiler\src\semantics\typeck\lifetimes.rs:263:13
    |
263 |         let mut errors = Vec::new();
    |             ----^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `size`
   --> compiler\src\codegen\asm\x86_64.rs:770:58
    |
770 |             MirOperand::Constant(MirConstant::Float(val, size)) => {
    |                                                          ^^^^ help: if this is intentional, prefix it with an underscore: `_size`

warning: unused variable: `suffix`
   --> compiler\src\codegen\asm\x86_64.rs:804:13
    |
804 |         let suffix = match width {
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_suffix`

warning: unused variable: `param_idx`
   --> compiler\src\codegen\asm\x86_64.rs:871:14
    |
871 |         for (param_idx, hint) in &callee_saved_needed {
    |              ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_param_idx`

warning: unused variable: `hint`
   --> compiler\src\codegen\asm\x86_64.rs:871:25
    |
871 |         for (param_idx, hint) in &callee_saved_needed {
    |                         ^^^^ help: if this is intentional, prefix it with an underscore: `_hint`

warning: unused variable: `param`
   --> compiler\src\codegen\asm\x86_64.rs:893:17
    |
893 |         for (i, param) in func.params.iter().enumerate() {
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_param`

warning: unused variable: `func`
   --> compiler\src\codegen\asm\x86_64.rs:914:33
    |
914 |     fn emit_epilogue(&mut self, func: &MirFunction) {
    |                                 ^^^^ help: if this is intentional, prefix it with an underscore: `_func`

warning: unused variable: `param_idx`
   --> compiler\src\codegen\asm\aarch64.rs:794:14
    |
794 |         for (param_idx, hint) in &callee_saved_needed {
    |              ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_param_idx`

warning: unused variable: `hint`
   --> compiler\src\codegen\asm\aarch64.rs:794:25
    |
794 |         for (param_idx, hint) in &callee_saved_needed {
    |                         ^^^^ help: if this is intentional, prefix it with an underscore: `_hint`

warning: unused variable: `param`
   --> compiler\src\codegen\asm\aarch64.rs:816:17
    |
816 |         for (i, param) in func.params.iter().enumerate() {
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_param`

warning: unused variable: `src`
   --> compiler\src\codegen\asm\aarch64.rs:962:21
    |
962 |                 let src = self.place_to_str(place);
    |                     ^^^ help: if this is intentional, prefix it with an underscore: `_src`

warning: unused variable: `src`
   --> compiler\src\codegen\asm\aarch64.rs:998:29
    |
998 |                         let src = self.place_to_str(place);
    |                             ^^^ help: if this is intentional, prefix it with an underscore: `_src`

warning: unused variable: `param_idx`
   --> compiler\src\codegen\asm\riscv64.rs:729:14
    |
729 |         for (param_idx, hint) in &callee_saved_needed {
    |              ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_param_idx`

warning: unused variable: `hint`
   --> compiler\src\codegen\asm\riscv64.rs:729:25
    |
729 |         for (param_idx, hint) in &callee_saved_needed {
    |                         ^^^^ help: if this is intentional, prefix it with an underscore: `_hint`

warning: unused variable: `param`
   --> compiler\src\codegen\asm\riscv64.rs:742:17
    |
742 |         for (i, param) in func.params.iter().enumerate() {
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_param`

warning: unused variable: `op`
   --> compiler\src\codegen\asm\riscv64.rs:933:17
    |
933 |                 op,
    |                 ^^ help: try ignoring the field: `op: _`

warning: unused variable: `binding`
   --> compiler\src\mir\builder.rs:354:44
    |
354 |                     ast::LoopKind::ForIn { binding, iterable } => {
    |                                            ^^^^^^^ help: try ignoring the field: `binding: _`

warning: unused variable: `iterable`
   --> compiler\src\mir\builder.rs:354:53
    |
354 |                     ast::LoopKind::ForIn { binding, iterable } => {
    |                                                     ^^^^^^^^ help: try ignoring the field: `iterable: _`

warning: unused variable: `guard_op`
   --> compiler\src\mir\builder.rs:483:29
    |
483 |                         let guard_op = self.lower_expr_to_operand(guard);
    |                             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_guard_op`

warning: unused variable: `span`
   --> compiler\src\mir\builder.rs:574:45
    |
574 |             ast::Expr::Call { callee, args, span } => {
    |                                             ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `generics`
   --> compiler\src\mir\builder.rs:857:38
    |
857 |             ast::Type::Named { name, generics, .. } => {
    |                                      ^^^^^^^^ help: try ignoring the field: `generics: _`

warning: unused variable: `object`
   --> compiler\src\mir\builder.rs:922:34
    |
922 |     fn lookup_field_index(&self, object: &ast::Expr, field_name: &str) -> Option<usize> {
    |                                  ^^^^^^ help: if this is intentional, prefix it with an underscore: `_object`

warning: unused variable: `func`
   --> compiler\src\mir\nll.rs:518:41
    |
518 |     fn propagate_constraints(&mut self, func: &MirFunction) {
    |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_func`

warning: unused variable: `place`
   --> compiler\src\mir\passes.rs:793:30
    |
793 |             MirOperand::Copy(place) | MirOperand::Move(place) => {
    |                              ^^^^^                     ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
793 |             MirOperand::Copy(_place) | MirOperand::Move(_place) => {
    |                              +                          +

warning: unused variable: `new_local`
   --> compiler\src\mir\passes.rs:945:26
    |
945 |             if let Some(&new_local) = local_remap.get(&(idx + 1)) {
    |                          ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_local`

warning: unused variable: `source_idx`
    --> compiler\src\mir\passes.rs:1427:33
     |
1427 |                     if let Some(source_idx) = func.blocks.iter().position(|b| b.id == source_id) {
     |                                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_source_idx`

warning: unused variable: `body`
    --> compiler\src\mir\passes.rs:1775:9
     |
1775 |         body: &HashSet<usize>,
     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_body`

warning: unused variable: `header`
    --> compiler\src\mir\passes.rs:1817:9
     |
1817 |         header: usize,
     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_header`

warning: unused variable: `dest`
    --> compiler\src\mir\passes.rs:2062:44
     |
2062 |                     MirInstruction::Load { dest, ptr } => {
     |                                            ^^^^ help: try ignoring the field: `dest: _`

warning: unused variable: `j`
    --> compiler\src\mir\passes.rs:2252:18
     |
2252 |             for (j, access2) in self.accesses.iter().enumerate().skip(i + 1) {
     |                  ^ help: if this is intentional, prefix it with an underscore: `_j`

warning: unused variable: `func`
    --> compiler\src\mir\passes.rs:2317:39
     |
2317 |     fn optimize_strided_access(&self, func: &mut MirFunction) {
     |                                       ^^^^ help: if this is intentional, prefix it with an underscore: `_func`

warning: unused variable: `kind`
    --> compiler\src\mir\passes.rs:2778:65
     |
2778 |                         if let MirRvalue::Aggregate { operands, kind } = value {
     |                                                                 ^^^^ help: try ignoring the field: `kind: _`

warning: unused variable: `op`
    --> compiler\src\mir\passes.rs:2861:42
     |
2861 |     fn check_operand_escaping(&mut self, op: &MirOperand) {
     |                                          ^^ help: if this is intentional, prefix it with an underscore: `_op`

warning: unused variable: `types`
   --> compiler\src\philosophy\nyaya\anumana.rs:235:41
    |
235 |             HetuPattern::BinaryOp { op, types } => expression.contains(op),
    |                                         ^^^^^ help: try ignoring the field: `types: _`

warning: unused variable: `name`
   --> compiler\src\philosophy\nyaya\upamana.rs:273:37
    |
273 |             PatternTemplate::Call { name, args } => {
    |                                     ^^^^ help: try ignoring the field: `name: _`

warning: unused variable: `args`
   --> compiler\src\philosophy\nyaya\upamana.rs:273:43
    |
273 |             PatternTemplate::Call { name, args } => {
    |                                           ^^^^ help: try ignoring the field: `args: _`

warning: unused variable: `receiver`
   --> compiler\src\philosophy\nyaya\upamana.rs:281:43
    |
281 |             PatternTemplate::MethodCall { receiver, method, args } => {
    |                                           ^^^^^^^^ help: try ignoring the field: `receiver: _`

warning: unused variable: `args`
   --> compiler\src\philosophy\nyaya\upamana.rs:281:61
    |
281 |             PatternTemplate::MethodCall { receiver, method, args } => {
    |                                                             ^^^^ help: try ignoring the field: `args: _`

warning: unused variable: `arg_name`
   --> compiler\src\philosophy\nyaya\shabda.rs:298:18
    |
298 |         for (i, (arg_name, arg_type)) in args.iter().enumerate() {
    |                  ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_arg_name`

warning: unused variable: `premise`
   --> compiler\src\philosophy\nyaya\mod.rs:179:31
    |
179 |     fn premise_matches(&self, premise: &Premise, expr: &str, ctx: &[(&str, &str)]) -> bool {
    |                               ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_premise`

warning: unused variable: `expr`
   --> compiler\src\philosophy\nyaya\mod.rs:179:50
    |
179 |     fn premise_matches(&self, premise: &Premise, expr: &str, ctx: &[(&str, &str)]) -> bool {
    |                                                  ^^^^ help: if this is intentional, prefix it with an underscore: `_expr`

warning: unused variable: `ctx`
   --> compiler\src\philosophy\nyaya\mod.rs:179:62
    |
179 |     fn premise_matches(&self, premise: &Premise, expr: &str, ctx: &[(&str, &str)]) -> bool {
    |                                                              ^^^ help: if this is intentional, prefix it with an underscore: `_ctx`

warning: unused variable: `name`
   --> compiler\src\philosophy\nyaya\mod.rs:185:26
    |
185 |     pub fn shabda(&self, name: &str, docs: &str) -> Option<TypeEvidence> {
    |                          ^^^^ help: if this is intentional, prefix it with an underscore: `_name`

warning: unused variable: `a`
   --> compiler\src\philosophy\nyaya\mod.rs:215:35
    |
215 |     fn expressions_similar(&self, a: &str, b: &str) -> bool {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_a`

warning: unused variable: `b`
   --> compiler\src\philosophy\nyaya\mod.rs:215:44
    |
215 |     fn expressions_similar(&self, a: &str, b: &str) -> bool {
    |                                            ^ help: if this is intentional, prefix it with an underscore: `_b`

warning: unused variable: `alignment`
   --> compiler\src\philosophy\advaita\mod.rs:135:42
    |
135 |     fn select_region(&self, size: usize, alignment: usize) -> Option<String> {
    |                                          ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_alignment`

warning: unused variable: `expression`
   --> compiler\src\mimamsa\mod.rs:126:31
    |
126 |     pub fn anupalabdhi(&self, expression: &str, available_info: &[&str]) -> Option<TypeEvidence> {
    |                               ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expression`

warning: unused variable: `k`
   --> compiler\src\tantra\sri_yantra.rs:237:48
    |
237 |     pub fn can_simd(&self, m: usize, n: usize, k: usize) -> bool {
    |                                                ^ help: if this is intentional, prefix it with an underscore: `_k`

warning: unused variable: `id`
   --> compiler\src\yoga\ashtanga\pranayama.rs:202:14
    |
202 |         for (id, (prana, amount, allocated_at)) in &self.allocations {
    |              ^^ help: if this is intentional, prefix it with an underscore: `_id`

warning: unused variable: `check`
   --> compiler\src\yoga\ashtanga\mod.rs:207:28
    |
207 |     fn passes_check(&self, check: &str, code: &str) -> bool {
    |                            ^^^^^ help: if this is intentional, prefix it with an underscore: `_check`

warning: unused variable: `code`
   --> compiler\src\yoga\ashtanga\mod.rs:207:41
    |
207 |     fn passes_check(&self, check: &str, code: &str) -> bool {
    |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_code`

warning: unused variable: `other`
  --> compiler\src\garuda\dataflow\mod.rs:60:20
   |
60 |     fn meet(&self, other: &Self) -> Self {
   |                    ^^^^^ help: if this is intentional, prefix it with an underscore: `_other`

warning: variable does not need to be mutable
   --> compiler\src\garuda\dataflow\mod.rs:298:25
    |
298 |                     let mut new_in = if block == cfg.entry {
    |                         ----^^^^^^
    |                         |
    |                         help: remove this `mut`

warning: unused variable: `op`
   --> compiler\src\garuda\narakas\andhakupa.rs:209:26
    |
209 |             left, right, op, ..
    |                          ^^ help: try ignoring the field: `op: _`

warning: unused variable: `op`
  --> compiler\src\garuda\narakas\asipatravana.rs:89:41
   |
89 |             Expr::Binary { left, right, op, span } => {
   |                                         ^^ help: try ignoring the field: `op: _`

warning: unused variable: `span`
  --> compiler\src\garuda\narakas\asipatravana.rs:89:45
   |
89 |             Expr::Binary { left, right, op, span } => {
   |                                             ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `kind`
   --> compiler\src\garuda\narakas\kalasutra.rs:102:38
    |
102 |             Stmt::Loop { body, span, kind } => {
    |                                      ^^^^ help: try ignoring the field: `kind: _`

warning: unused variable: `span`
  --> compiler\src\garuda\narakas\puyoda.rs:91:42
   |
91 |             Expr::Index { object, index, span } => {
   |                                          ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `span`
   --> compiler\src\garuda\narakas\raurava.rs:159:17
    |
159 |                 span,
    |                 ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `span`
   --> compiler\src\garuda\narakas\sulaprota.rs:160:17
    |
160 |                 span,
    |                 ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `span`
   --> compiler\src\garuda\vaitarani\boundary.rs:295:17
    |
295 |                 span,
    |                 ^^^^ help: try ignoring the field: `span: _`

warning: unused variable: `required`
   --> compiler\src\garuda\vaitarani\boundary.rs:445:33
    |
445 |                     if let Some(required) = self.boundary.sensitive_sinks.get(&ident.name) {
    |                                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_required`

warning: unused variable: `location`
  --> compiler\src\garuda\yama\sentence.rs:23:37
   |
23 |     pub fn generate(naraka: Naraka, location: &Span, details: &str) -> Self {
   |                                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_location`

warning: variable does not need to be mutable
   --> compiler\src\devatas\rudras.rs:123:29
    |
123 |     pub fn transform(&self, mut state: CompilationState) -> CompilationState {
    |                             ----^^^^^
    |                             |
    |                             help: remove this `mut`

warning: unused variable: `func`
   --> compiler\src\margas\karma.rs:107:9
    |
107 |         func: &MirFunction,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_func`

warning: unused variable: `header`
   --> compiler\src\margas\karma.rs:130:79
    |
130 |     fn detect_induction_var(&self, func: &MirFunction, body: &HashSet<usize>, header: usize) -> Option<usize> {
    |                                                                               ^^^^^^ help: if this is intentional, prefix it with an underscore: `_header`

warning: variable does not need to be mutable
   --> compiler\src\varnas\varna_checker.rs:215:13
    |
215 |         let mut violations = Vec::new();
    |             ----^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `entry_id`
   --> compiler\src\modules\mod.rs:118:13
    |
118 |         let entry_id = self.discover_modules(entry_file)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_entry_id`

warning: unused variable: `from`
   --> compiler\src\modules\mod.rs:189:9
    |
189 |         from: ModuleId,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_from`

warning: unused variable: `mantra`
   --> compiler\src\driver\session.rs:321:29
    |
321 | ...                   mantra,
    |                       ^^^^^^ help: try ignoring the field: `mantra: _`

warning: unused variable: `start`
   --> compiler\src\driver\session.rs:393:13
    |
393 |         let start = Instant::now();
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_start`

warning: field `index` is never read
   --> compiler\src\diagnostics\sink.rs:201:5
    |
199 | pub struct DiagnosticIter<'a> {
    |            -------------- field in this struct
200 |     collector: &'a DiagnosticCollector,
201 |     index: usize,
    |     ^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: fields `dhatu_dict` and `sandhi_fst` are never read
  --> compiler\src\lexer\mod.rs:33:5
   |
27 | pub struct Lexer<'src> {
   |            ----- fields in this struct
...
33 |     dhatu_dict: Option<&'src DhatuDictionary>,
   |     ^^^^^^^^^^
34 |     /// Sandhi FST for phonetic splitting (optional)
35 |     sandhi_fst: Option<&'src SandhiFst>,
   |     ^^^^^^^^^^

warning: field `cache` is never read
  --> compiler\src\lexer\sandhi.rs:49:5
   |
43 | pub struct SandhiFst {
   |            --------- field in this struct
...
49 |     cache: HashMap<String, Vec<String>>,
   |     ^^^^^

warning: fields `parent` and `is_loop` are never read
   --> compiler\src\semantics\borrow.rs:137:5
    |
133 | struct ScopeInfo {
    |        --------- fields in this struct
...
137 |     parent: Option<usize>,
    |     ^^^^^^
...
143 |     is_loop: bool,
    |     ^^^^^^^
    |
    = note: `ScopeInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `name`, `params`, `return_ownership`, and `output_param` are never read
   --> compiler\src\semantics\borrow.rs:150:5
    |
148 | struct FunctionContext {
    |        --------------- fields in this struct
149 |     /// Function name
150 |     name: String,
    |     ^^^^
151 |     /// Parameter names and their ownership kinds
152 |     params: HashMap<String, OwnershipKind>,
    |     ^^^^^^
153 |     /// Return type ownership
154 |     return_ownership: Option<OwnershipKind>,
    |     ^^^^^^^^^^^^^^^^
155 |     /// Output parameter (for linear returns)
156 |     output_param: Option<String>,
    |     ^^^^^^^^^^^^
    |
    = note: `FunctionContext` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `name` and `lifetime_params` are never read
   --> compiler\src\semantics\lifetime.rs:105:5
    |
103 | struct FunctionLifetimeContext {
    |        ----------------------- fields in this struct
104 |     /// Function name
105 |     name: String,
    |     ^^^^
106 |     /// Named lifetime parameters
107 |     lifetime_params: HashMap<String, u8>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `FunctionLifetimeContext` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `name` and `generics` are never read
  --> compiler\src\semantics\typeck_impl.rs:60:9
   |
59 | pub struct TypeDefInfo {
   |            ----------- fields in this struct
60 |     pub name: String,
   |         ^^^^
61 |     pub generics: Vec<String>,
   |         ^^^^^^^^
   |
   = note: `TypeDefInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `0` is never read
  --> compiler\src\semantics\typeck_impl.rs:70:11
   |
70 |     Alias(ResolvedType),
   |     ----- ^^^^^^^^^^^^
   |     |
   |     field in this variant
   |
   = note: `TypeBodyResolved` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
   |
70 -     Alias(ResolvedType),
70 +     Alias(()),
   |

warning: fields `name` and `span` are never read
  --> compiler\src\semantics\typeck_impl.rs:76:9
   |
75 | pub struct FunctionSig {
   |            ----------- fields in this struct
76 |     pub name: String,
   |         ^^^^
...
79 |     pub span: Option<Span>,
   |         ^^^^
   |
   = note: `FunctionSig` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `generalize` and `instantiate` are never used
   --> compiler\src\semantics\typeck_impl.rs:453:8
    |
223 | impl TypeInference {
    | ------------------ methods in this implementation
...
453 |     fn generalize(&self, ty: &ResolvedType, env_vars: &[TypeVar]) -> ResolvedType {
    |        ^^^^^^^^^^
...
460 |     fn instantiate(&mut self, ty: &ResolvedType) -> ResolvedType {
    |        ^^^^^^^^^^^

warning: field `substitutions` is never read
   --> compiler\src\semantics\typeck\generics.rs:157:5
    |
153 | pub struct PolymorphismEngine {
    |            ------------------ field in this struct
...
157 |     substitutions: HashMap<TypeVar, ResolvedType>,
    |     ^^^^^^^^^^^^^

warning: struct `SpillDecision` is never constructed
   --> compiler\src\codegen\asm\x86_64.rs:243:8
    |
243 | struct SpillDecision {
    |        ^^^^^^^^^^^^^

warning: fields `xmm_available`, `xmm_used`, `live_intervals`, and `next_spill_slot` are never read
   --> compiler\src\codegen\asm\x86_64.rs:261:5
    |
251 | struct X86RegAlloc {
    |        ----------- fields in this struct
...
261 |     xmm_available: Vec<XmmReg>,
    |     ^^^^^^^^^^^^^
262 |     /// Used XMM registers
263 |     xmm_used: Vec<XmmReg>,
    |     ^^^^^^^^
264 |     /// Live intervals for linear scan register allocation
265 |     live_intervals: Vec<LiveInterval>,
    |     ^^^^^^^^^^^^^^
266 |     /// Next available spill slot offset
267 |     next_spill_slot: i64,
    |     ^^^^^^^^^^^^^^^

warning: multiple fields are never read
   --> compiler\src\codegen\asm\x86_64.rs:274:5
    |
272 | struct LiveInterval {
    |        ------------ fields in this struct
273 |     /// Variable/local index
274 |     local: usize,
    |     ^^^^^
275 |     /// Start instruction index
276 |     start: usize,
    |     ^^^^^
277 |     /// End instruction index
278 |     end: usize,
    |     ^^^
279 |     /// Assigned register (None if spilled)
280 |     assigned_reg: Option<X86Reg>,
    |     ^^^^^^^^^^^^
281 |     /// Is this a float?
282 |     is_float: bool,
    |     ^^^^^^^^
283 |     /// Assigned XMM register if float
284 |     assigned_xmm: Option<XmmReg>,
    |     ^^^^^^^^^^^^
285 |     /// Spill slot offset if spilled
286 |     spill_slot: Option<i64>,
    |     ^^^^^^^^^^
    |
    = note: `LiveInterval` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `allocate_xmm`, `free_xmm`, and `linear_scan_allocate` are never used
   --> compiler\src\codegen\asm\x86_64.rs:337:8
    |
289 | impl X86RegAlloc {
    | ---------------- methods in this implementation
...
337 |     fn allocate_xmm(&mut self) -> Option<XmmReg> {
    |        ^^^^^^^^^^^^
...
344 |     fn free_xmm(&mut self, reg: XmmReg) {
    |        ^^^^^^^^
...
357 |     fn linear_scan_allocate(
    |        ^^^^^^^^^^^^^^^^^^^^

warning: method `operand_to_str` is never used
   --> compiler\src\codegen\asm\x86_64.rs:549:8
    |
514 | impl X86_64Emitter {
    | ------------------ method in this implementation
...
549 |     fn operand_to_str(&self, operand: &MirOperand) -> String {
    |        ^^^^^^^^^^^^^^

warning: field `v_available` is never read
   --> compiler\src\codegen\asm\aarch64.rs:242:5
    |
232 | struct AArch64RegAlloc {
    |        --------------- field in this struct
...
242 |     v_available: Vec<VReg>,
    |     ^^^^^^^^^^^

warning: method `const_to_str` is never used
   --> compiler\src\codegen\asm\aarch64.rs:463:8
    |
429 | impl AArch64Emitter {
    | ------------------- method in this implementation
...
463 |     fn const_to_str(&self, constant: &MirConstant) -> String {
    |        ^^^^^^^^^^^^

warning: field `platform` is never read
  --> compiler\src\codegen\linker.rs:17:5
   |
11 | pub struct Assembler {
   |            --------- field in this struct
...
17 |     platform: Platform,
   |     ^^^^^^^^

warning: field `linker` is never read
   --> compiler\src\codegen\linker.rs:380:5
    |
378 | pub struct BuildPipeline {
    |            ------------- field in this struct
379 |     assembler: Assembler,
380 |     linker: Linker,
    |     ^^^^^^

warning: methods `karaka_to_class`, `num_gp_registers`, and `num_callee_saved` are never used
   --> compiler\src\codegen\regalloc.rs:338:8
    |
 81 | impl RegisterAllocator {
    | ---------------------- methods in this implementation
...
338 |     fn karaka_to_class(&self, karaka: &Karaka) -> RegisterClass {
    |        ^^^^^^^^^^^^^^^
...
612 |     fn num_gp_registers(&self) -> usize {
    |        ^^^^^^^^^^^^^^^^
...
621 |     fn num_callee_saved(&self) -> usize {
    |        ^^^^^^^^^^^^^^^^

warning: field `current_function` is never read
  --> compiler\src\mir\builder.rs:14:5
   |
12 | pub struct MirBuilder {
   |            ---------- field in this struct
13 |     /// Current function being built
14 |     current_function: Option<MirFunction>,
   |     ^^^^^^^^^^^^^^^^

warning: fields `guna` and `const_prop` are never read
  --> compiler\src\mir\optimizer.rs:13:5
   |
 9 | pub struct MirOptimizer {
   |            ------------ fields in this struct
...
13 |     guna: GunaMode,
   |     ^^^^
...
21 |     const_prop: ConstantPropagation,
   |     ^^^^^^^^^^

warning: field `induction_var` is never read
    --> compiler\src\mir\passes.rs:1632:5
     |
1622 | struct NaturalLoop {
     |        ----------- field in this struct
...
1632 |     induction_var: Option<(usize, i64)>,
     |     ^^^^^^^^^^^^^
     |
     = note: `NaturalLoop` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `type_idx` is never read
    --> compiler\src\mir\passes.rs:2398:5
     |
2396 | struct FieldAccessInfo {
     |        --------------- field in this struct
2397 |     /// Type index (for grouping accesses to same type)
2398 |     type_idx: usize,
     |     ^^^^^^^^
     |
     = note: `FieldAccessInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `local` is never read
    --> compiler\src\mir\passes.rs:2732:5
     |
2730 | struct AggregateInfo {
     |        ------------- field in this struct
2731 |     /// Local index of the aggregate
2732 |     local: usize,
     |     ^^^^^
     |
     = note: `AggregateInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `similarity_rules` is never read
  --> compiler\src\philosophy\nyaya\upamana.rs:18:5
   |
14 | pub struct UpamanaEngine {
   |            ------------- field in this struct
...
18 |     similarity_rules: Vec<SimilarityRule>,
   |     ^^^^^^^^^^^^^^^^

warning: field `cache_line_size` is never read
  --> compiler\src\philosophy\advaita\brahman_memory.rs:25:5
   |
15 | pub struct BrahmanMemory {
   |            ------------- field in this struct
...
25 |     cache_line_size: usize,
   |     ^^^^^^^^^^^^^^^

warning: field `start_time` is never read
  --> compiler\src\ayurveda\mod.rs:61:5
   |
53 | pub struct AyurvedaMonitor {
   |            --------------- field in this struct
...
61 |     start_time: Instant,
   |     ^^^^^^^^^^

warning: field `patterns` is never read
  --> compiler\src\tantra\mod.rs:71:5
   |
67 | pub struct YantraOptimizer {
   |            --------------- field in this struct
...
71 |     patterns: Vec<YantraPattern>,
   |     ^^^^^^^^

warning: fields `cache_line_size` and `l2_size` are never read
  --> compiler\src\tantra\sri_yantra.rs:17:5
   |
15 | pub struct ShriYantra {
   |            ---------- fields in this struct
16 |     /// Cache line size (bytes)
17 |     cache_line_size: usize,
   |     ^^^^^^^^^^^^^^^
...
21 |     l2_size: usize,
   |     ^^^^^^^

warning: fields `global_vars` and `max_nesting` are never read
  --> compiler\src\yoga\ashtanga\yama.rs:79:5
   |
73 | pub struct YamaChecker {
   |            ----------- fields in this struct
...
79 |     global_vars: HashSet<String>,
   |     ^^^^^^^^^^^
80 |     /// Nesting depth tracker
81 |     max_nesting: HashMap<String, usize>,
   |     ^^^^^^^^^^^

warning: struct `FixApplicator` is never constructed
  --> compiler\src\garuda\moksha\suggestion.rs:75:12
   |
75 | pub struct FixApplicator;
   |            ^^^^^^^^^^^^^

warning: associated function `apply` is never used
  --> compiler\src\garuda\moksha\suggestion.rs:79:12
   |
77 | impl FixApplicator {
   | ------------------ associated function in this implementation
78 |     /// Apply fixes to source code
79 |     pub fn apply(source: &str, fixes: &[FixSuggestion]) -> String {
   |            ^^^^^

warning: field `secure_alternatives` is never read
  --> compiler\src\garuda\narakas\ksharakardama.rs:18:5
   |
12 | pub struct KsharakardamaChecker {
   |            -------------------- field in this struct
...
18 |     secure_alternatives: HashSet<&'static str>,
   |     ^^^^^^^^^^^^^^^^^^^

warning: field `graceful_fns` is never read
  --> compiler\src\garuda\narakas\maharaurava.rs:16:5
   |
12 | pub struct MaharauravaChecker {
   |            ------------------ field in this struct
...
16 |     graceful_fns: HashSet<&'static str>,
   |     ^^^^^^^^^^^^

warning: enum `LockState` is never used
  --> compiler\src\garuda\narakas\pranarodha.rs:13:6
   |
13 | enum LockState {
   |      ^^^^^^^^^

warning: variant `Returned` is never constructed
  --> compiler\src\garuda\narakas\sarameyadana.rs:17:5
   |
13 | enum PointerState {
   |      ------------ variant in this enum
...
17 |     Returned, // Pointer to local returned
   |     ^^^^^^^^
   |
   = note: `PointerState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `collection_types` is never read
  --> compiler\src\garuda\narakas\suchimukha.rs:24:5
   |
20 | pub struct SuchimukhaChecker {
   |            ----------------- field in this struct
...
24 |     collection_types: HashSet<&'static str>,
   |     ^^^^^^^^^^^^^^^^

warning: field `async_alts` is never read
  --> compiler\src\garuda\narakas\sukaramukha.rs:16:5
   |
12 | pub struct SukaramukhaChecker {
   |            ------------------ field in this struct
...
16 |     async_alts: HashSet<&'static str>,
   |     ^^^^^^^^^^

warning: variant `Moved` is never constructed
  --> compiler\src\garuda\narakas\tamisram.rs:16:5
   |
13 | enum MemoryState {
   |      ----------- variant in this enum
...
16 |     Moved,
   |     ^^^^^
   |
   = note: `MemoryState` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `name` is never read
   --> compiler\src\garuda\preta\detector.rs:144:5
    |
142 | struct ResourceAllocation {
    |        ------------------ field in this struct
143 |     /// Variable name
144 |     name: String,
    |     ^^^^
    |
    = note: `ResourceAllocation` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `count_blocks` and `count_stmt_blocks` are never used
   --> compiler\src\garuda\preta\detector.rs:289:8
    |
177 | impl PretaDetector {
    | ------------------ methods in this implementation
...
289 |     fn count_blocks(&self, block: &Block) -> usize {
    |        ^^^^^^^^^^^^
...
297 |     fn count_stmt_blocks(&self, stmt: &Stmt) -> usize {
    |        ^^^^^^^^^^^^^^^^^

warning: fields `tainted` and `violations` are never read
  --> compiler\src\garuda\vaitarani\boundary.rs:63:5
   |
52 | pub struct VaitaraniBoundary {
   |            ----------------- fields in this struct
...
63 |     tainted: HashMap<String, TaintInfo>,
   |     ^^^^^^^
...
66 |     violations: Vec<VaitaraniViolation>,
   |     ^^^^^^^^^^

warning: struct `SqlPurifier` is never constructed
  --> compiler\src\garuda\vaitarani\purification.rs:26:12
   |
26 | pub struct SqlPurifier;
   |            ^^^^^^^^^^^

warning: struct `HtmlPurifier` is never constructed
  --> compiler\src\garuda\vaitarani\purification.rs:46:12
   |
46 | pub struct HtmlPurifier;
   |            ^^^^^^^^^^^^

warning: struct `ShellPurifier` is never constructed
  --> compiler\src\garuda\vaitarani\purification.rs:65:12
   |
65 | pub struct ShellPurifier;
   |            ^^^^^^^^^^^^^

warning: field `description` is never read
  --> compiler\src\garuda\yama\dharmaraja.rs:23:9
   |
21 | pub struct DharmaRule {
   |            ---------- field in this struct
22 |     pub name: String,
23 |     pub description: String,
   |         ^^^^^^^^^^^

warning: fields `max_inline_size` and `max_unroll` are never read
  --> compiler\src\astras\agneyastra.rs:20:5
   |
18 | pub struct Agneyastra {
   |            ---------- fields in this struct
19 |     /// Maximum inline size (instructions)
20 |     max_inline_size: usize,
   |     ^^^^^^^^^^^^^^^
21 |     /// Maximum unroll factor
22 |     max_unroll: usize,
   |     ^^^^^^^^^^

warning: field `inline_threshold` is never read
  --> compiler\src\astras\brahmashira.rs:29:5
   |
25 | pub struct Brahmashira {
   |            ----------- field in this struct
...
29 |     inline_threshold: usize,
   |     ^^^^^^^^^^^^^^^^

warning: field `types` is never read
   --> compiler\src\astras\brahmashira.rs:100:5
    |
 98 | struct ForwardInfo {
    |        ----------- field in this struct
 99 |     constants: Vec<(String, i64)>,
100 |     types: Vec<(String, String)>,
    |     ^^^^^

warning: field `branch_predictions` is never read
   --> compiler\src\astras\brahmashira.rs:116:5
    |
114 | struct SpeculativeInfo {
    |        --------------- field in this struct
115 |     hot_paths: Vec<Vec<String>>,
116 |     branch_predictions: Vec<(String, bool)>,
    |     ^^^^^^^^^^^^^^^^^^

warning: field `aggressive` is never read
  --> compiler\src\astras\brahmastra.rs:20:5
   |
18 | pub struct Brahmastra {
   |            ---------- field in this struct
19 |     /// Whether to be aggressive in elimination
20 |     aggressive: bool,
   |     ^^^^^^^^^^

warning: field `scalar_replacement` is never read
  --> compiler\src\astras\garudastra.rs:20:5
   |
18 | pub struct Garudastra {
   |            ---------- field in this struct
19 |     /// Whether to apply scalar replacement
20 |     scalar_replacement: bool,
   |     ^^^^^^^^^^^^^^^^^^

warning: field `non_escaping` is never read
  --> compiler\src\astras\garudastra.rs:48:5
   |
47 | struct EscapeInfo {
   |        ---------- field in this struct
48 |     non_escaping: Vec<String>,     // objects that don't escape
   |     ^^^^^^^^^^^^

warning: method `determine_ordering` is never used
  --> compiler\src\astras\indrastra.rs:46:8
   |
34 | impl Indrastra {
   | -------------- method in this implementation
...
46 |     fn determine_ordering(&self, _module: &MirModule) -> Vec<String> {
   |        ^^^^^^^^^^^^^^^^^^

warning: field `variable` is never read
   --> compiler\src\astras\nagapasha.rs:164:5
    |
163 | struct CaptureDecision {
    |        --------------- field in this struct
164 |     variable: String,
    |     ^^^^^^^^

warning: field `size` is never read
   --> compiler\src\astras\nagapasha.rs:171:5
    |
170 | struct EnvironmentLayout {
    |        ----------------- field in this struct
171 |     size: usize,
    |     ^^^^

warning: variant `Invalid` is never constructed
   --> compiler\src\astras\nagapasha.rs:181:5
    |
179 | enum LifetimeResult {
    |      -------------- variant in this enum
180 |     Valid,
181 |     Invalid(String),
    |     ^^^^^^^

warning: field `analysis_depth` is never read
  --> compiler\src\astras\nagastra.rs:20:5
   |
18 | pub struct Nagastra {
   |            -------- field in this struct
19 |     /// Analysis depth
20 |     analysis_depth: usize,
   |     ^^^^^^^^^^^^^^

warning: fields `aliases` and `escape_set` are never read
  --> compiler\src\astras\nagastra.rs:46:5
   |
45 | struct PointerInfo {
   |        ----------- fields in this struct
46 |     aliases: Vec<(String, String)>, // pairs that may alias
   |     ^^^^^^^
47 |     escape_set: Vec<String>,        // pointers that escape
   |     ^^^^^^^^^^

warning: field `sample_rate` is never read
  --> compiler\src\astras\suryaastra.rs:32:5
   |
26 | pub struct Suryaastra {
   |            ---------- field in this struct
...
32 |     sample_rate: u32,
   |     ^^^^^^^^^^^

warning: fields `location` and `kind` are never read
   --> compiler\src\astras\suryaastra.rs:120:5
    |
119 | struct HotspotInfo {
    |        ----------- fields in this struct
120 |     location: String,
    |     ^^^^^^^^
121 |     kind: HotspotKind,
    |     ^^^^

warning: field `function_name` is never read
   --> compiler\src\astras\suryaastra.rs:153:5
    |
152 | struct HeatMap {
    |        ------- field in this struct
153 |     function_name: String,
    |     ^^^^^^^^^^^^^

warning: field `optimize_layout` is never read
  --> compiler\src\astras\varunastra.rs:20:5
   |
18 | pub struct Varunastra {
   |            ---------- field in this struct
19 |     /// Whether to optimize memory layout
20 |     optimize_layout: bool,
   |     ^^^^^^^^^^^^^^^

warning: fields `live_ranges` and `def_use_chains` are never read
  --> compiler\src\astras\varunastra.rs:46:5
   |
45 | struct DataflowInfo {
   |        ------------ fields in this struct
46 |     live_ranges: Vec<(String, usize, usize)>, // (var, start, end)
   |     ^^^^^^^^^^^
47 |     def_use_chains: Vec<(String, usize, Vec<usize>)>, // (var, def_site, use_sites)
   |     ^^^^^^^^^^^^^^

warning: field `eliminate_unreachable` is never read
  --> compiler\src\astras\vayuastra.rs:20:5
   |
18 | pub struct Vayuastra {
   |            --------- field in this struct
19 |     /// Whether to eliminate unreachable blocks
20 |     eliminate_unreachable: bool,
   |     ^^^^^^^^^^^^^^^^^^^^^

warning: field `base_local` is never read
  --> compiler\src\margas\bhakti.rs:27:5
   |
25 | struct MemoryPattern {
   |        ------------- field in this struct
26 |     /// Base local
27 |     base_local: usize,
   |     ^^^^^^^^^^
   |
   = note: `MemoryPattern` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `block` and `instructions` are never read
  --> compiler\src\margas\bhakti.rs:40:5
   |
38 | struct ParallelOpportunity {
   |        ------------------- fields in this struct
39 |     /// Block ID where parallelism is possible
40 |     block: usize,
   |     ^^^^^
41 |     /// Instructions that can be parallelized
42 |     instructions: Vec<usize>,
   |     ^^^^^^^^^^^^
   |
   = note: `ParallelOpportunity` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: variant `Gpu` is never constructed
  --> compiler\src\margas\bhakti.rs:54:5
   |
48 | enum ParallelKind {
   |      ------------ variant in this enum
...
54 |     Gpu,
   |     ^^^
   |
   = note: `ParallelKind` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `memo_cache` is never read
  --> compiler\src\margas\jnana.rs:24:5
   |
18 | pub struct JnanaMarga {
   |            ---------- field in this struct
...
24 |     memo_cache: HashMap<String, MirConstant>,
   |     ^^^^^^^^^^

warning: fields `block`, `inst_idx`, `func_name`, and `const_args` are never read
  --> compiler\src\margas\jnana.rs:48:5
   |
46 | struct CallInfo {
   |        -------- fields in this struct
47 |     /// Block ID
48 |     block: usize,
   |     ^^^^^
49 |     /// Instruction index
50 |     inst_idx: usize,
   |     ^^^^^^^^
51 |     /// Function name
52 |     func_name: String,
   |     ^^^^^^^^^
53 |     /// Arguments (if constant)
54 |     const_args: Vec<Option<MirConstant>>,
   |     ^^^^^^^^^^
   |
   = note: `CallInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `header`, `back_edge_src`, and `induction_var` are never read
  --> compiler\src\margas\karma.rs:35:5
   |
33 | struct LoopInfo {
   |        -------- fields in this struct
34 |     /// Header block ID
35 |     header: usize,
   |     ^^^^^^
36 |     /// Back edge source
37 |     back_edge_src: usize,
   |     ^^^^^^^^^^^^^
...
41 |     induction_var: Option<usize>,
   |     ^^^^^^^^^^^^^
   |
   = note: `LoopInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `state_var` and `transitions` are never read
  --> compiler\src\margas\karma.rs:50:5
   |
48 | struct StateMachineInfo {
   |        ---------------- fields in this struct
49 |     /// State variable local
50 |     state_var: usize,
   |     ^^^^^^^^^
...
54 |     transitions: Vec<(i64, usize, i64)>, // (from_state, block, to_state)
   |     ^^^^^^^^^^^
   |
   = note: `StateMachineInfo` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `capabilities` is never read
  --> compiler\src\varnas\brahmin.rs:18:5
   |
16 | pub struct BrahminPrivilege {
   |            ---------------- field in this struct
17 |     /// All capabilities are available
18 |     capabilities: Vec<Capability>,
   |     ^^^^^^^^^^^^

warning: field `strict` is never read
  --> compiler\src\varnas\varna_checker.rs:19:5
   |
17 | pub struct VarnaChecker {
   |            ------------ field in this struct
18 |     /// Enable strict mode (no implicit elevations)
19 |     strict: bool,
   |     ^^^^^^

warning: field `kind` is never read
   --> compiler\src\modules\symbol.rs:117:5
    |
113 | struct Scope {
    |        ----- field in this struct
...
117 |     kind: ScopeKind,
    |     ^^^^
    |
    = note: `Scope` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: struct `AtomicRevision` is never constructed
  --> compiler\src\queries\revision.rs:67:12
   |
67 | pub struct AtomicRevision {
   |            ^^^^^^^^^^^^^^

warning: associated items `new`, `get`, `increment`, and `set` are never used
  --> compiler\src\queries\revision.rs:74:12
   |
72 | impl AtomicRevision {
   | ------------------- associated items in this implementation
73 |     /// Create a new atomic revision
74 |     pub fn new() -> Self {
   |            ^^^
...
81 |     pub fn get(&self) -> Revision {
   |            ^^^
...
88 |     pub fn increment(&self) -> Revision {
   |            ^^^^^^^^^
...
94 |     pub fn set(&self, revision: Revision) {
   |            ^^^

warning: field `pipeline` is never read
  --> compiler\src\driver\session.rs:19:5
   |
15 | pub struct CompilerSession {
   |            --------------- field in this struct
...
19 |     pipeline: SamkhyaPipeline,
   |     ^^^^^^^^

warning: `jagannath-compiler` (lib) generated 237 warnings (run `cargo fix --lib -p jagannath-compiler` to apply 156 suggestions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.55s
