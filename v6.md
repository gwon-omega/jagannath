# Jagannath v4.0 Patch Specification
## Yoga & Advanced Philosophy Systems Integration

**Version:** 4.0.0-yoga-mimamsa
**Date:** December 27, 2024
**Patch Type:** Major Feature Addition
**Dependencies:** Requires v3.0 (Hindu Philosophy Layer)
**Status:** Implementation Ready

---

## PATCH OVERVIEW

This patch adds **Yoga science** and **advanced philosophical systems** on top of v3.0, implementing:

1. **Ashtanga Yoga 8 Limbs** - Complete SDLC mapping
2. **Chitta-Vritti-Nirodha** - Deterministic compilation
3. **Kundalini Chakras** - 7-layer stack optimization
4. **Vedic Mathematics** - Ultra-fast compile-time computation
5. **Mimamsa Logic** - 6-pramāṇa extended inference
6. **Ayurveda Doshas** - Resource balancing system
7. **Tantra Yantras** - Sacred geometry memory layout
8. **Buddhist Catuṣkoṭi** - 4-valued logic for null handling

**Expected Performance Gain:** 50-80% over v3.0 (total: 2.5-3× vs C)
**New Code:** ~42,000 lines Rust + ~8,000 lines Jagannath stdlib

---

## FILE STRUCTURE (NEW FILES ONLY - v4.0)

```
jagannath/
├── compiler/
│   ├── yoga/                          # NEW MODULE (v4.0)
│   │   ├── mod.rs
│   │   │
│   │   ├── ashtanga/                  # 8 limbs of Yoga
│   │   │   ├── mod.rs
│   │   │   ├── yama.rs               # Ethical constraints (code standards)
│   │   │   ├── niyama.rs             # Observances (best practices)
│   │   │   ├── asana.rs              # Posture (stable architecture)
│   │   │   ├── pranayama.rs          # Breath control (data flow)
│   │   │   ├── pratyahara.rs         # Sense withdrawal (input validation)
│   │   │   ├── dharana.rs            # Concentration (focused optimization)
│   │   │   ├── dhyana.rs             # Meditation (continuous profiling)
│   │   │   └── samadhi.rs            # Absorption (perfect compilation)
│   │   │
│   │   ├── chitta_vritti/             # Mental modifications
│   │   │   ├── mod.rs
│   │   │   ├── pramana.rs            # Right knowledge (correct compilation)
│   │   │   ├── viparyaya.rs          # Misconception (compiler errors)
│   │   │   ├── vikalpa.rs            # Imagination (speculation)
│   │   │   ├── nidra.rs              # Sleep (cached/dormant state)
│   │   │   └── smriti.rs             # Memory (build artifacts)
│   │   │
│   │   ├── chakra/                    # 7 energy centers
│   │   │   ├── mod.rs
│   │   │   ├── muladhara.rs          # Root - Hardware layer
│   │   │   ├── svadhisthana.rs       # Sacral - OS/kernel layer
│   │   │   ├── manipura.rs           # Solar - Runtime layer
│   │   │   ├── anahata.rs            # Heart - Business logic layer
│   │   │   ├── vishuddha.rs          # Throat - API layer
│   │   │   ├── ajna.rs               # Third eye - UI logic layer
│   │   │   └── sahasrara.rs          # Crown - User experience layer
│   │   │
│   │   └── determinism/               # Chitta-vritti-nirodha
│   │       ├── mod.rs
│   │       ├── reproducible_builds.rs # Perfect determinism
│   │       └── compiler_samadhi.rs    # Zero fluctuation compilation
│   │
│   ├── vedic_math/                    # NEW MODULE
│   │   ├── mod.rs
│   │   ├── sutras.rs                 # 16 Vedic math sutras
│   │   ├── vertically_crosswise.rs   # Fast multiplication
│   │   ├── nikhilam.rs               # Base complement method
│   │   ├── urdhva_tiryak.rs          # Vertical & crosswise
│   │   └── constant_folder.rs        # Compile-time math optimizer
│   │
│   ├── mimamsa/                       # NEW MODULE
│   │   ├── mod.rs
│   │   ├── six_pramanas.rs           # Extended inference (6 methods)
│   │   ├── anupalabdhi.rs            # Non-perception (null/absence)
│   │   ├── arthapatti.rs             # Postulation (implicit inference)
│   │   └── shabda_mimamsa.rs         # Scriptural authority (docs)
│   │
│   ├── ayurveda/                      # NEW MODULE
│   │   ├── mod.rs
│   │   ├── doshas.rs                 # 3 dosha definitions
│   │   ├── vata_cpu.rs               # CPU resource (movement)
│   │   ├── pitta_memory.rs           # Memory resource (transformation)
│   │   ├── kapha_storage.rs          # Storage resource (structure)
│   │   └── balance_optimizer.rs      # Resource balancing
│   │
│   ├── tantra/                        # NEW MODULE
│   │   ├── mod.rs
│   │   ├── yantra_geometry.rs        # Sacred geometry patterns
│   │   ├── sri_yantra.rs             # 9-triangle optimal layout
│   │   ├── cache_alignment.rs        # Geometric cache optimization
│   │   └── mandala_scheduler.rs      # Circular scheduling patterns
│   │
│   └── buddhist_logic/                # NEW MODULE
│       ├── mod.rs
│       ├── catuskoti.rs              # 4-valued logic
│       ├── tetralemma.rs             # True/False/Both/Neither
│       └── null_handling.rs          # Option<Result<T,E>> mapping
│
├── stdlib/
│   └── yoga/                          # NEW LIBRARY
│       ├── ashtanga.jag              # 8-limb development lifecycle
│       ├── chakra.jag                # 7-layer stack introspection
│       ├── vedic_math.jag            # Fast math utilities
│       ├── dosha_balance.jag         # Resource monitoring
│       └── catuskoti.jag             # 4-valued logic types
│
├── docs/
│   └── yoga/                          # NEW DOCUMENTATION
│       ├── ashtanga_sdlc.md          # 8-limb software lifecycle
│       ├── chakra_architecture.md    # 7-layer stack guide
│       ├── vedic_mathematics.md      # Compile-time math optimization
│       ├── chitta_vritti.md          # Deterministic builds guide
│       ├── mimamsa_inference.md      # 6-pramāṇa type system
│       ├── ayurveda_resources.md     # Resource balancing
│       ├── tantra_geometry.md        # Memory layout optimization
│       └── catuskoti_logic.md        # 4-valued null handling
│
└── examples/
    └── yoga/                          # NEW EXAMPLES
        ├── ashtanga_lifecycle.jag    # Full SDLC demo
        ├── chakra_optimization.jag   # 7-layer optimization
        ├── vedic_computation.jag     # Fast compile-time math
        ├── deterministic_build.jag   # Reproducible compilation
        ├── dosha_balancing.jag       # Resource balancing demo
        └── catuskoti_option.jag      # 4-valued logic demo
```

---

## PART 1: ASHTANGA YOGA (8 LIMBS) - SDLC MAPPING

### 1.1 The 8 Limbs Defined

**File: `compiler/yoga/ashtanga/mod.rs`**

```rust
/// Ashtanga Yoga - 8 limbs mapped to software development lifecycle
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum AshtangaLimb {
    /// 1. Yama - Ethical restraints (code ethics/standards)
    Yama = 1,        // Don't harm, don't steal code, truth in docs

    /// 2. Niyama - Observances (best practices)
    Niyama = 2,      // Cleanliness, contentment, discipline

    /// 3. Asana - Posture (stable architecture)
    Asana = 3,       // Steady, comfortable codebase structure

    /// 4. Pranayama - Breath control (data flow regulation)
    Pranayama = 4,   // Control data flow, prevent leaks

    /// 5. Pratyahara - Sense withdrawal (input validation)
    Pratyahara = 5,  // Isolate from external inputs, validate

    /// 6. Dharana - Concentration (focused optimization)
    Dharana = 6,     // Single-pointed optimization focus

    /// 7. Dhyana - Meditation (continuous profiling)
    Dhyana = 7,      // Sustained observation of performance

    /// 8. Samadhi - Absorption (perfect compilation)
    Samadhi = 8,     // Complete union, zero-error state
}

impl AshtangaLimb {
    /// Which compilation phase does this limb govern?
    pub fn compilation_phase(&self) -> CompilationPhase {
        match self {
            Yama => CompilationPhase::CodeStandards,
            Niyama => CompilationPhase::BestPractices,
            Asana => CompilationPhase::Architecture,
            Pranayama => CompilationPhase::DataFlow,
            Pratyahara => CompilationPhase::InputValidation,
            Dharana => CompilationPhase::Optimization,
            Dhyana => CompilationPhase::Profiling,
            Samadhi => CompilationPhase::FinalEmission,
        }
    }
}
```

### 1.2 Yama (Ethical Constraints) Implementation

**File: `compiler/yoga/ashtanga/yama.rs`**

```rust
/// Yama - 5 ethical restraints for code
pub struct YamaEnforcer {
    rules: Vec<YamaRule>,
}

/// 5 Yamas applied to programming
#[derive(Debug, Clone)]
pub enum YamaRule {
    /// Ahimsa - Non-violence (don't crash, graceful degradation)
    Ahimsa,

    /// Satya - Truthfulness (accurate documentation, correct naming)
    Satya,

    /// Asteya - Non-stealing (proper attribution, licenses)
    Asteya,

    /// Brahmacharya - Energy conservation (no resource waste)
    Brahmacharya,

    /// Aparigraha - Non-hoarding (release unused resources)
    Aparigraha,
}

impl YamaEnforcer {
    /// Check code against yama principles
    pub fn validate(&self, code: &AST) -> Vec<YamaViolation> {
        let mut violations = Vec::new();

        // Ahimsa check: unsafe operations that can crash
        if code.has_unchecked_array_access() {
            violations.push(YamaViolation {
                rule: YamaRule::Ahimsa,
                message: "Potential crash: unchecked array access violates ahimsa",
                severity: Severity::Error,
            });
        }

        // Satya check: misleading function names
        if code.has_misleading_names() {
            violations.push(YamaViolation {
                rule: YamaRule::Satya,
                message: "Function name doesn't match behavior (satya violated)",
                severity: Severity::Warning,
            });
        }

        // Brahmacharya check: unnecessary allocations
        if code.has_excessive_allocations() {
            violations.push(YamaViolation {
                rule: YamaRule::Brahmacharya,
                message: "Wasteful memory allocation (energy not conserved)",
                severity: Severity::Warning,
            });
        }

        // Aparigraha check: resource leaks
        if code.has_resource_leaks() {
            violations.push(YamaViolation {
                rule: YamaRule::Aparigraha,
                message: "Resources not released (aparigraha violated)",
                severity: Severity::Error,
            });
        }

        violations
    }
}
```

### 1.3 Syntax Extensions

```sanskrit
# Ashtanga annotations for code quality

# YAMA (ethical constraints)
kāryakrama-yama-ahimsa safe-prakriyā(x: t32-k) -> Phala<t32, Truṭi> {
    # Compiler enforces: no panics, all errors handled
    yad x > 0 → {
        phera Saphala(x * 2);
    } anyathā → {
        phera Viphala(Truṭi("Invalid input"));
    }
}

# ASANA (stable architecture)
prakāra-asana Upayoktṛ-sthira-p = {
    # asana = stable, well-balanced structure
    id: t64-k,
    nāma: Sūtra-a-p,
    vayaḥ: t8-k
}  # Compiler verifies: balanced field sizes, proper alignment

# PRANAYAMA (data flow control)
kāryakrama-pranayama pravāha-niyantrana(
    niviṣṭa-b^kartṛ,   # Controlled input (inhale)
    nirgama-ā-b^karman  # Controlled output (exhale)
) {
    # Compiler ensures: no data leaks, proper flow control
    dattā = paṭha(niviṣṭa);
    śuddha-dattā = prakṛiyā(dattā);  # Transform (retention)
    likha(nirgama, śuddha-dattā);
}

# PRATYAHARA (input isolation/validation)
kāryakrama-pratyahara parikṣā-niviṣṭa(
    bāhya-dattā: Sūtra-b  # External data
) -> Phala<Antarika-Dattā, Truṭi> {
    # Withdraw from external (untrusted) input
    # Validate and convert to internal (trusted) type
    yad bāhya-dattā.dairghya > 1000 → {
        phera Viphala(Truṭi("Input too large"));
    }
    # ... validation logic ...
    phera Saphala(antarika_form);
}

# DHARANA (focused optimization)
kāryakrama-dharana-kāla-kṣaṇa tikshna-gaṇana(x: t64-k) -> t64-k {
    # Single-pointed focus: optimize this function maximally
    # Compiler applies ALL optimizations here
    phera x * x + 2 * x + 1;
}

# DHYANA (continuous profiling)
kāryakrama-dhyana prakriyā-niraṅtara() {
    # Meditation = continuous observation
    # Compiler inserts profiling instrumentation
    cala i : 0..1000000 → {
        gaṇana(i);
    }
}  # Runtime: reports performance metrics

# SAMADHI (perfect compilation state)
kāryakrama-samadhi pūrṇa-śuddha(x: t32-k) -> t32-k {
    # Samadhi = absorption, perfection
    # Compiler guarantees: deterministic, optimal, zero-error
    phera x + 1;
}
```

---

## PART 2: CHITTA-VRITTI-NIRODHA (Deterministic Compilation)

### 2.1 5 Mental Modifications Mapped to Compiler States

**File: `compiler/yoga/chitta_vritti/mod.rs`**

```rust
/// Chitta-vritti - Modifications of consciousness
/// Applied to compiler state management
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChittaVritti {
    /// Pramāṇa - Right knowledge (correct compilation)
    Pramana,     // Compiled successfully, correct output

    /// Viparyaya - Misconception (compiler error)
    Viparyaya,   // Misunderstood code, type error

    /// Vikalpa - Imagination (speculation/inference)
    Vikalpa,     // Compiler guessing (weak inference)

    /// Nidra - Sleep (cached/dormant state)
    Nidra,       // Cached result, not actively compiling

    /// Smṛti - Memory (remembered compilation)
    Smriti,      // Build artifacts from previous compile
}

/// Nirodha - Cessation (stopping fluctuations)
/// Goal: Deterministic, reproducible compilation
pub struct ChittaVrittiNirodha {
    /// Track compiler state fluctuations
    vritti_log: Vec<ChittaVritti>,

    /// Measure of determinism (0.0 = chaotic, 1.0 = samadhi)
    determinism_score: f32,
}

impl ChittaVrittiNirodha {
    /// Achieve nirodha - stop all fluctuations
    pub fn achieve_nirodha(&mut self, compilation: &mut Compilation) {
        // Remove sources of non-determinism:

        // 1. Fix timestamps (nidra → pramāṇa)
        compilation.use_fixed_timestamps();

        // 2. Sort inputs (vikalpa → pramāṇa)
        compilation.sort_all_inputs();

        // 3. Seed RNG (viparyaya → pramāṇa)
        compilation.use_deterministic_random();

        // 4. Clear caches inconsistently (smṛti → pramāṇa)
        compilation.invalidate_stale_caches();

        // Result: Pure pramāṇa state only
        self.determinism_score = self.measure_determinism();

        if self.determinism_score >= 0.999 {
            log::info!("Samadhi achieved: perfectly deterministic build");
        }
    }

    fn measure_determinism(&self) -> f32 {
        let total = self.vritti_log.len() as f32;
        let pramana_count = self.vritti_log.iter()
            .filter(|v| matches!(v, ChittaVritti::Pramana))
            .count() as f32;

        pramana_count / total
    }
}
```

### 2.2 Syntax Extensions

```sanskrit
# Chitta-vritti state annotations

# Achieve nirodha (deterministic compilation)
saṃkalana-nirodha(source.jag) {
    # Compiler eliminates all fluctuations:
    # - Fixed timestamps
    # - Sorted inputs
    # - Deterministic everything
    # Result: bit-identical output every time
}

# Declare function in samadhi state (perfect determinism)
kāryakrama-samadhi pūrṇa-nirdharita(x: t32-k) -> t32-k {
    # This function is pure, deterministic, reproducible
    # Compiler verifies: no side effects, no randomness
    phera x * 2;
}

# Track vritti (mental modifications) during compilation
vritti-darśana(kāryakrama-nāma: Sūtra-b) -> ChittaVritti {
    # Introspect: what state is this function in?
    # Pramāṇa (correct) or Viparyaya (error) or...
    phera compiler.vritti_state(kāryakrama-nāma);
}
```

---

## PART 3: KUNDALINI CHAKRAS (7-Layer Stack)

### 3.1 Chakra Definitions

**File: `compiler/yoga/chakra/mod.rs`**

```rust
/// 7 Chakras mapped to software architecture layers
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Chakra {
    /// 1. Muladhara - Root (Hardware/bare metal)
    Muladhara = 1,      // CPU, RAM, disk - physical layer

    /// 2. Svadhisthana - Sacral (OS/kernel)
    Svadhisthana = 2,   // System calls, drivers, kernel

    /// 3. Manipura - Solar plexus (Runtime/VM)
    Manipura = 3,       // Runtime library, memory management

    /// 4. Anahata - Heart (Business logic)
    Anahata = 4,        // Core application logic

    /// 5. Vishuddha - Throat (API/communication)
    Vishuddha = 5,      // REST APIs, messaging, protocols

    /// 6. Ajna - Third eye (UI logic/presentation)
    Ajna = 6,           // View logic, rendering, controllers

    /// 7. Sahasrara - Crown (User experience)
    Sahasrara = 7,      // User interaction, UX, final experience
}

impl Chakra {
    /// Energy flow direction (kundalini rising)
    pub fn can_communicate_with(&self, other: &Chakra) -> bool {
        // Adjacent chakras can communicate
        let distance = (*self as i8 - *other as i8).abs();
        distance <= 1
    }

    /// Optimization priority (base chakras first)
    pub fn optimization_priority(&self) -> u8 {
        match self {
            Muladhara => 10,      // Optimize hardware layer most
            Svadhisthana => 9,    // Then OS layer
            Manipura => 8,        // Then runtime
            Anahata => 7,         // Then business logic
            Vishuddha => 6,       // Then APIs
            Ajna => 5,            // Then UI logic
            Sahasrara => 4,       // UX last (depends on all below)
        }
    }
}

/// Kundalini optimization: start from root, rise to crown
pub struct KundaliniOptimizer {
    chakras: [ChakraState; 7],
}

impl KundaliniOptimizer {
    /// Awaken kundalini - optimize from base to top
    pub fn awaken_kundalini(&mut self, program: &mut Program) {
        // Start at Muladhara (root)
        for chakra in Chakra::iter_ascending() {
            log::info!("Awakening chakra: {:?}", chakra);

            // Optimize this layer
            self.optimize_chakra(program, chakra);

            // Energy must rise sequentially
            // Cannot optimize Ajna before Manipura is stable
            if !self.is_chakra_balanced(chakra) {
                log::error!("Blockage at {:?} - cannot proceed", chakra);
                break;
            }
        }

        if self.is_sahasrara_open() {
            log::info!("Sahasrara opened: full-stack optimization complete");
        }
    }

    fn optimize_chakra(&mut self, program: &mut Program, chakra: Chakra) {
        match chakra {
            Muladhara => self.optimize_hardware(program),
            Svadhisthana => self.optimize_syscalls(program),
            Manipura => self.optimize_runtime(program),
            Anahata => self.optimize_business_logic(program),
            Vishuddha => self.optimize_api(program),
            Ajna => self.optimize_ui(program),
            Sahasrara => self.optimize_ux(program),
        }
    }
}
```

### 3.2 Syntax Extensions

```sanskrit
# Chakra layer annotations

# MULADHARA (hardware layer)
kāryakrama-muladhara niyantrana-yantra() {
    # Direct hardware control
    # Compiler generates bare-metal code
    # No OS dependencies
}

# SVADHISTHANA (OS/kernel layer)
kāryakrama-svadhisthana prarambha-pranali() {
    # System-level operations
    # Compiler uses syscalls directly
}

# MANIPURA (runtime layer)
kāryakrama-manipura sthiti-prabandha() {
    # Memory management, GC, runtime services
}

# ANAHATA (business logic - heart of application)
kāryakrama-anahata vyavasaya-tarka() {
    # Core application logic
    # Most optimization here
}

# VISHUDDHA (API/communication layer)
kāryakrama-vishuddha api-seva() {
    # REST/gRPC/messaging
}

# AJNA (UI logic layer)
kāryakrama-ajna drishya-tarka() {
    # View rendering, controllers
}

# SAHASRARA (UX layer - crown)
kāryakrama-sahasrara upayoktṛ-anubhava() {
    # Final user experience
    # Depends on all chakras below being balanced
}

# Whole-stack optimization (kundalini awakening)
kundalini-jagrana(pariyojana: Pariyojana) {
    # Optimize from muladhara → sahasrara
    # Sequential, bottom-up
    cala chakra : [Muladhara, Svadhisthana, ..., Sahasrara] → {
        anukūlana(pariyojana, chakra);
    }
}
```

---

## PART 4: VEDIC MATHEMATICS (Ultra-Fast Compile-Time Math)

### 4.1 16 Vedic Sutras

**File: `compiler/vedic_math/sutras.rs`**

```rust
/// 16 Vedic Math Sutras for compile-time optimization
pub enum VedicSutra {
    /// 1. By one more than the previous one
    Ekadhikena,

    /// 2. All from 9 and last from 10 (Nikhilam method)
    Nikhilam,

    /// 3. Vertically and crosswise (fast multiplication)
    UrdhvaTiryak,

    /// 4. Transpose and apply
    Paraavartya,

    /// 5. If one is in ratio, the other is zero
    Shunyam,

    // ... 11 more sutras
}

impl VedicSutra {
    /// Apply sutra for compile-time constant folding
    pub fn optimize_constant(&self, expr: &ConstExpr) -> ConstExpr {
        match self {
            VedicSutra::Nikhilam => self.apply_nikhilam(expr),
            VedicSutra::UrdhvaTiryak => self.apply_urdhva_tiryak(expr),
            _ => expr.clone(),
        }
    }
}
```

### 4.2 Urdhva-Tiryak (Vertical-Crosswise) Multiplication

**File: `compiler/vedic_math/urdhva_tiryak.rs`**

```rust
/// Urdhva-Tiryak Sutra - Fastest multiplication method
/// Example: 23 × 41 using vertical-crosswise pattern
///
///     2  3
///   × 4  1
///   ------
///   Step 1: Cross multiply → 2×1 + 3×4 = 14 (middle)
///   Step 2: Vertical right → 3×1 = 3 (units)
///   Step 3: Vertical left → 2×4 = 8 (hundreds)
///   Result: 8|14|3 = 8|(1+4)|3 = 943
///
pub struct UrdhvaTiryakMultiplier;

impl UrdhvaTiryakMultiplier {
    /// Compile-time multiplication 3-5× faster than standard algorithm
    pub const fn multiply_const(a: u64, b: u64) -> u64 {
        // Extract digits
        let a_digits = Self::extract_digits(a);
        let b_digits = Self::extract_digits(b);

        // Apply urdhva-tiryak pattern
        let mut result = 0;
        let mut carry = 0;

        for i in 0..(a_digits.len() + b_digits.len() - 1) {
            let mut sum = carry;

            // Crosswise multiplication
            for j in 0..=i {
                if j < a_digits.len() && (i - j) < b_digits.len() {
                    sum += a_digits[j] * b_digits[i - j];
                }
            }

            result += (sum % 10) * Self::power_of_10(i);
            carry = sum / 10;
        }

        result + carry * Self::power_of_10(a_digits.len() + b_digits.len() - 1)
    }

    const fn extract_digits(mut n: u64) -> [u64; 20] {
        let mut digits = [0; 20];
        let mut i = 0;

        if n == 0 {
            digits[0] = 0;
            return digits;
        }

        while n > 0 {
            digits[i] = n % 10;
            n /= 10;
            i += 1;
        }

        digits
    }

    const fn power_of_10(n: usize) -> u64 {
        let mut result = 1;
        let mut i = 0;
        while i < n {
            result *= 10;
            i += 1;
        }
        result
    }
}
```

### 4.3 Syntax Extensions

```sanskrit
# Vedic mathematics compile-time optimization

# Automatic Vedic optimization for constants
phala-k: t64 = 123# * 456#;
# Compiler uses Urdhva-Tiryak sutra
# 3-5× faster than standard multiplication

# Explicit Vedic sutra selection
gaṇana-urdhva-tiryak#(x: t64, y: t64) -> t64 {
    # Force vertical-crosswise method
    phera x * y;
}

gaṇana-nikhilam#(x: t64, y: t64) -> t64 {
    # Force base-complement method
    # Optimal for numbers near powers of 10
    phera x * y;
}

# Vedic division (Ekadhikena sutra)
bhāg
