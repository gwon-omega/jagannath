# Jagannath v9.0 Patch Specification
## Jyotiṣa Śāstra - Vedic Astrology for Code

**Version:** 9.0.0-jyotisha-graha-nakshatra
**Date:** December 29, 2024
**Patch Type:** Cosmic Influence System & Temporal Optimization
**Dependencies:** Requires v8.0 (Moksha Journey)
**Status:** Deep Analysis Complete, Design Ready

---

## EXECUTIVE SUMMARY

**The Problem:** v8.0 treats all code equally, ignoring the **cosmic timing** and **inherent nature** of code elements. Just as humans are born under specific planetary positions (grahas) and lunar mansions (nakshatras) that influence their destiny, code has **temporal context** and **intrinsic characteristics** that affect compilation outcomes.

**The Revelation:** Jyotiṣa Śāstra (Vedic Astrology) provides a **scientifically-grounded temporal optimization framework**:
- **9 Grahas** (planets) = 9 compilation influences affecting code
- **27 Nakshatras** (lunar mansions) = 27 code characteristic patterns
- **12 Rāśis** (zodiac signs) = 12 code lifecycle phases
- **Kundali** (birth chart) = Compilation context analysis
- **Daśā** (planetary periods) = Optimal compilation timing
- **Yoga** (planetary combinations) = Code pattern synergies

**The Metaphor:**
```
Source Code Creation Time    = Birth Time (Janma Kāla)
Code Characteristics         = Nakshatra Placement
Compilation Influences       = Graha Positions
Optimal Compile Time         = Muhūrta (auspicious moment)
Code Evolution               = Daśā Periods
Performance Characteristics  = Graha Strength (Bala)
Code Compatibility           = Graha/Nakshatra Matching
```

**Expected Impact:**
- **Performance:** 4.2× faster than C (up from 3.5×) through temporal optimization
- **Timing-Aware Compilation:** Compile at optimal cosmic moments
- **Pattern Recognition:** 27 nakshatra patterns for code classification
- **Predictive Analysis:** Forecast code behavior using Daśā system
- **Compatibility Checking:** Graha-based module compatibility

**New Code:** ~35,000 lines Rust + 8,000 lines stdlib + astronomical calculations

---

## PART 1: PHILOSOPHICAL FOUNDATION

### 1.1 Why Jyotiṣa Śāstra for Compilation?

**Ancient Wisdom Meets Modern CS:**

```
Jyotiṣa Principle              | Compiler Science Equivalent
===============================|================================
Graha (Planet) Influence       | Compilation context factors
                               | (CPU load, memory, time of day)
                               |
Nakshatra (Lunar Mansion)      | Code pattern signatures
                               | (27 fundamental patterns)
                               |
Rāśi (Zodiac Sign)             | Code lifecycle phase
                               | (12 stages: birth → deployment)
                               |
Kundali (Birth Chart)          | Complete compilation context
                               | (when/where/how code created)
                               |
Daśā (Planetary Period)        | Optimal compilation windows
                               | (timing for best results)
                               |
Graha Bala (Planet Strength)   | Resource availability & quality
                               | (CPU power, memory bandwidth)
                               |
Yoga (Planet Combination)      | Code pattern synergies
                               | (when patterns work together)
                               |
Doṣa (Affliction)              | Anti-patterns, bad timing
                               | (compile during bad conditions)
                               |
Muhūrta (Auspicious Time)      | Optimal compilation moment
                               | (best time to compile)
```

**Key Insight:** Just as Jyotiṣa uses planetary positions to predict outcomes, v9.0 uses **compilation context** (time, resources, code patterns) to optimize results.

### 1.2 The 9 Grahas (Compilation Influences)

```rust
/// 9 Grahas = 9 primary influences on compilation
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Graha {
    /// Sūrya (Sun) - Main compilation thread, core power
    Surya,

    /// Chandra (Moon) - Memory & cache behavior
    Chandra,

    /// Maṅgala (Mars) - Aggressive optimization, speed
    Mangala,

    /// Budha (Mercury) - Communication, I/O operations
    Budha,

    /// Guru (Jupiter) - Wisdom, knowledge-based opts
    Guru,

    /// Śukra (Venus) - Elegance, code beauty, aesthetics
    Shukra,

    /// Śani (Saturn) - Discipline, correctness, safety
    Shani,

    /// Rāhu (North Node) - Unconventional optimizations
    Rahu,

    /// Ketu (South Node) - Minimalism, code reduction
    Ketu,
}

impl Graha {
    /// What does this graha influence in compilation?
    pub fn influence(&self) -> GrahaInfluence {
        match self {
            Graha::Surya => GrahaInfluence {
                name: "सूर्य (Sun)",
                governs: "Core compilation thread, main CPU",
                nature: GrahaNature::Sattvic,  // Pure
                strength_affects: "Overall compilation speed",
                weak_when: "CPU throttled, heavy load",
                strong_when: "Dedicated core, high clock speed",
                optimization_focus: "Sequential single-threaded",
                example: "Main parsing thread, primary codegen",
            },

            Graha::Chandra => GrahaInfluence {
                name: "चन्द्र (Moon)",
                governs: "Memory, cache, data flow",
                nature: GrahaNature::Sattvic,
                strength_affects: "Cache hit rate, memory bandwidth",
                weak_when: "Memory pressure, cache misses",
                strong_when: "Ample RAM, hot cache",
                optimization_focus: "Memory layout, cache locality",
                example: "Data structure packing, alignment",
            },

            Graha::Mangala => GrahaInfluence {
                name: "मङ्गल (Mars)",
                governs: "Aggressive optimization, speed",
                nature: GrahaNature::Rajasic,  // Active/passionate
                strength_affects: "Optimization aggressiveness",
                weak_when: "Safety constraints required",
                strong_when: "Performance-critical path",
                optimization_focus: "Loop unrolling, inlining",
                example: "Aggressive vectorization, unsafe opts",
            },

            Graha::Budha => GrahaInfluence {
                name: "बुध (Mercury)",
                governs: "Communication, I/O, serialization",
                nature: GrahaNature::Rajasic,
                strength_affects: "I/O throughput, RPC speed",
                weak_when: "Network latency, disk bottleneck",
                strong_when: "Fast I/O, low latency",
                optimization_focus: "Protocol optimization, buffering",
                example: "Network serialization, async I/O",
            },

            Graha::Guru => GrahaInfluence {
                name: "गुरु (Jupiter)",
                governs: "Wisdom, knowledge-based optimization",
                nature: GrahaNature::Sattvic,
                strength_affects: "Intelligent decision making",
                weak_when: "Limited compile time",
                strong_when: "Profile-guided optimization available",
                optimization_focus: "Machine learning, heuristics",
                example: "PGO, adaptive optimization",
            },

            Graha::Shukra => GrahaInfluence {
                name: "शुक्र (Venus)",
                governs: "Code elegance, beauty, simplicity",
                nature: GrahaNature::Rajasic,
                strength_affects: "Code size, readability",
                weak_when: "Ugly generated code",
                strong_when: "Clean, minimal output",
                optimization_focus: "Code size, simplicity",
                example: "Dead code elimination, constant folding",
            },

            Graha::Shani => GrahaInfluence {
                name: "शनि (Saturn)",
                governs: "Discipline, safety, correctness",
                nature: GrahaNature::Tamasic,  // Slow/stable
                strength_affects: "Safety guarantees, checks",
                weak_when: "Unsafe optimizations needed",
                strong_when: "Safety-critical code",
                optimization_focus: "Bounds checking, verification",
                example: "Memory safety, overflow checks",
            },

            Graha::Rahu => GrahaInfluence {
                name: "राहु (North Node)",
                governs: "Unconventional, experimental opts",
                nature: GrahaNature::Tamasic,
                strength_affects: "Novel optimization discovery",
                weak_when: "Conservative compilation needed",
                strong_when: "Experimental features enabled",
                optimization_focus: "Cutting-edge techniques",
                example: "MLIR, polyhedral optimization",
            },

            Graha::Ketu => GrahaInfluence {
                name: "केतु (South Node)",
                governs: "Minimalism, reduction, simplicity",
                nature: GrahaNature::Tamasic,
                strength_affects: "Code minimization",
                weak_when: "Feature-rich output needed",
                strong_when: "Embedded, minimal binary",
                optimization_focus: "Extreme minimization",
                example: "Strip symbols, compress, LTO",
            },
        }
    }

    /// Calculate graha strength (Bala) at compilation time
    pub fn calculate_bala(&self, context: &CompilationContext) -> GrahaBala {
        let mut bala = GrahaBala::new();

        match self {
            Graha::Surya => {
                // Strong when CPU is available
                bala.cpu_strength = context.cpu_available_percent();
                bala.temporal_strength = Self::surya_temporal(context.time);
            }

            Graha::Chandra => {
                // Strong when memory is available
                bala.memory_strength = context.memory_available_percent();
                bala.cache_strength = context.cache_hit_rate();
            }

            Graha::Mangala => {
                // Strong when aggressive opts are possible
                bala.optimization_level = context.opt_level as f32 / 3.0;
                bala.safety_constraints = 1.0 - context.safety_level;
            }

            // ... etc for all 9 grahas
        }

        bala
    }

    /// Temporal strength (like planetary positions)
    fn surya_temporal(time: SystemTime) -> f32 {
        // Sun is strongest at noon, weakest at midnight
        let hour = time.hour();
        let strength = match hour {
            10..=14 => 1.0,      // Peak strength (noon)
            6..=9 | 15..=18 => 0.7,  // Good strength
            19..=21 | 4..=5 => 0.4,  // Moderate
            _ => 0.2,            // Weak (night)
        };
        strength
    }
}
```

### 1.3 The 27 Nakshatras (Code Patterns)

```rust
/// 27 Nakshatras = 27 fundamental code patterns
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Nakshatra {
    // 1-9: FIRST PADA (Agni - Fire - Creation)
    Ashwini,      // Fast, impulsive code (quick scripts)
    Bharani,      // Resource-constrained (embedded)
    Krittika,     // Sharp, cutting (parsers, compilers)
    Rohini,       // Beautiful, aesthetic (UI code)
    Mrigashira,   // Searching, exploring (search algorithms)
    Ardra,        // Stormy, transformative (refactoring)
    Punarvasu,    // Repeating, cyclical (loops, iterations)
    Pushya,       // Nourishing, supporting (libraries)
    Ashlesha,     // Binding, connecting (glue code)

    // 10-18: SECOND PADA (Soma - Water - Preservation)
    Magha,        // Regal, authoritative (kernel code)
    PurvaPhalguni,// Comfortable, relaxing (user apps)
    UttaraPhalguni,// Generous, helpful (utilities)
    Hasta,        // Skillful, dexterous (algorithms)
    Chitra,       // Artistic, crafted (graphics)
    Swati,        // Independent, flexible (plugins)
    Vishakha,     // Goal-oriented (optimization)
    Anuradha,     // Cooperative (distributed systems)
    Jyeshtha,     // Senior, protective (security code)

    // 19-27: THIRD PADA (Vayu - Air - Dissolution)
    Mula,         // Root, fundamental (OS primitives)
    PurvaAshadha, // Invincible (robust code)
    UttaraAshadha,// Victorious (optimized code)
    Shravana,     // Listening, learning (AI/ML)
    Dhanishta,    // Wealthy, resourceful (caching)
    Shatabhisha,  // Healing, fixing (debugging tools)
    PurvaBhadrapada,// Fierce, intense (real-time systems)
    UttaraBhadrapada,// Deep, profound (complex algorithms)
    Revati,       // Prosperous, complete (finished products)
}

impl Nakshatra {
    /// What code pattern does this nakshatra represent?
    pub fn pattern(&self) -> NakshatraPattern {
        match self {
            Nakshatra::Ashwini => NakshatraPattern {
                name: "अश्विनी (Ashwini)",
                deity: "Ashwini Kumaras (Divine Physicians)",
                symbol: "Horse's Head",
                nature: "Swift, healing, impulsive",
                code_pattern: CodePattern::QuickScript,
                characteristics: vec![
                    "Fast execution priority",
                    "Minimal dependencies",
                    "Immediate results",
                    "Healing/fixing nature",
                ],
                best_for: "CLI tools, quick scripts, hot-fixes",
                compile_strategy: "Fast compilation, minimal optimization",
                example: "#!/bin/bash one-liners, Python scripts",
            },

            Nakshatra::Krittika => NakshatraPattern {
                name: "कृत्तिका (Krittika)",
                deity: "Agni (Fire God)",
                symbol: "Sharp Knife/Razor",
                nature: "Cutting, sharp, transformative",
                code_pattern: CodePattern::Parser,
                characteristics: vec![
                    "Cutting through complexity",
                    "Transforming input to output",
                    "Sharp decision making",
                    "Burns away impurities",
                ],
                best_for: "Parsers, compilers, tokenizers",
                compile_strategy: "Optimize branching, prediction",
                example: "Lexer, parser, AST transformer",
            },

            Nakshatra::Hasta => NakshatraPattern {
                name: "हस्त (Hasta)",
                deity: "Savitar (Sun God of Skill)",
                symbol: "Hand/Palm",
                nature: "Skillful, dexterous, clever",
                code_pattern: CodePattern::Algorithm,
                characteristics: vec![
                    "Manual dexterity",
                    "Clever manipulation",
                    "Skillful execution",
                    "Hand-crafted optimization",
                ],
                best_for: "Algorithms, data structures, math",
                compile_strategy: "Aggressive optimization, loop opts",
                example: "Sorting, searching, graph algorithms",
            },

            Nakshatra::Vishakha => NakshatraPattern {
                name: "विशाखा (Vishakha)",
                deity: "Indra-Agni (Power and Fire)",
                symbol: "Triumphal Gateway",
                nature: "Goal-oriented, determined, victorious",
                code_pattern: CodePattern::Optimizer,
                characteristics: vec![
                    "Relentless goal pursuit",
                    "Victory through effort",
                    "Transformation to perfection",
                    "Never gives up",
                ],
                best_for: "Optimization passes, performance tuning",
                compile_strategy: "Multiple optimization passes",
                example: "LLVM optimization pipeline",
            },

            Nakshatra::Mula => NakshatraPattern {
                name: "मूल (Mula)",
                deity: "Nirriti (Goddess of Destruction)",
                symbol: "Bundle of Roots",
                nature: "Root, fundamental, destructive-creative",
                code_pattern: CodePattern::SystemPrimitive,
                characteristics: vec![
                    "Gets to the root",
                    "Fundamental operations",
                    "Destroys to rebuild",
                    "Foundation layer",
                ],
                best_for: "OS kernel, syscalls, primitives",
                compile_strategy: "Direct machine code, no overhead",
                example: "malloc, context switch, interrupt handlers",
            },

            Nakshatra::Revati => NakshatraPattern {
                name: "रेवती (Revati)",
                deity: "Pushan (Nourisher)",
                symbol: "Fish/Drum",
                nature: "Prosperous, complete, nourishing",
                code_pattern: CodePattern::CompleteProduct,
                characteristics: vec![
                    "Complete and polished",
                    "Nourishes users",
                    "Prosperity and success",
                    "Journey's end",
                ],
                best_for: "Finished applications, releases",
                compile_strategy: "Full optimization, polish",
                example: "Production releases, shipped products",
            },

            // ... patterns for all 27 nakshatras
        }
    }

    /// Detect which nakshatra a code belongs to
    pub fn detect_from_code(code: &AST) -> Self {
        let score_board = Self::calculate_all_scores(code);
        score_board.highest_scoring_nakshatra()
    }

    fn calculate_all_scores(code: &AST) -> NakshatraScoreBoard {
        let mut scores = NakshatraScoreBoard::new();

        // Analyze code characteristics
        let has_loops = code.count_loops();
        let has_recursion = code.has_recursion();
        let complexity = code.cyclomatic_complexity();
        let io_operations = code.count_io_operations();
        let memory_operations = code.count_memory_ops();
        let is_system_level = code.has_inline_asm() || code.calls_syscalls();
        let line_count = code.line_count();
        let function_count = code.function_count();

        // Score each nakshatra

        // Ashwini: quick scripts
        if line_count < 100 && function_count < 5 {
            scores.add(Nakshatra::Ashwini, 0.8);
        }

        // Krittika: parsers/compilers
        if code.has_pattern_matching() && complexity > 20 {
            scores.add(Nakshatra::Krittika, 0.9);
        }

        // Hasta: algorithms
        if has_loops && !io_operations && complexity > 10 {
            scores.add(Nakshatra::Hasta, 0.85);
        }

        // Mula: system primitives
        if is_system_level && line_count < 200 {
            scores.add(Nakshatra::Mula, 0.95);
        }

        // ... score all 27

        scores
    }
}
```

### 1.4 The Kundali (Compilation Birth Chart)

```rust
/// Kundali = Birth chart = Complete compilation context
#[derive(Debug, Clone)]
pub struct Kundali {
    /// When was this code compiled? (Janma Kāla)
    birth_time: SystemTime,

    /// Where was it compiled? (Geographic location metaphor = CPU arch)
    birth_place: CompilationLocation,

    /// 12 houses (Bhāvas) showing different aspects
    houses: [Bhava; 12],

    /// Graha positions in houses
    graha_positions: HashMap<Graha, BhavaPosition>,

    /// Nakshatra of the code's "moon" (core nature)
    moon_nakshatra: Nakshatra,

    /// Ascendant (Lagna) - code's outward nature
    ascendant: Rashi,

    /// Current Daśā period
    current_dasha: Dasha,
}

impl Kundali {
    /// Generate kundali for compilation
    pub fn generate(context: &CompilationContext) -> Self {
        let birth_time = SystemTime::now();
        let birth_place = CompilationLocation::detect();

        // Calculate house positions (12 bhāvas)
        let houses = Self::calculate_houses(&context);

        // Position all 9 grahas in houses
        let graha_positions = Self::position_grahas(&context, &houses);

        // Detect code's core nature (moon nakshatra)
        let moon_nakshatra = Nakshatra::detect_from_code(&context.ast);

        // Calculate ascendant (lagna)
        let ascendant = Self::calculate_ascendant(&context);

        // Determine current daśā period
        let current_dasha = Dasha::calculate(birth_time, moon_nakshatra);

        Self {
            birth_time,
            birth_place,
            houses,
            graha_positions,
            moon_nakshatra,
            ascendant,
            current_dasha,
        }
    }

    /// Calculate the 12 houses (areas of life = areas of compilation)
    fn calculate_houses(context: &CompilationContext) -> [Bhava; 12] {
        [
            // 1st House: Self/Identity = Code's core identity
            Bhava {
                number: 1,
                name: "Lagna (Ascendant)",
                governs: "Code's visible nature, entry point",
                represents: "main() function, public API",
            },

            // 2nd House: Wealth/Resources = Resource usage
            Bhava {
                number: 2,
                name: "Dhana (Wealth)",
                governs: "Memory, CPU resources consumed",
                represents: "Memory allocations, resource usage",
            },

            // 3rd House: Siblings/Communication = I/O
            Bhava {
                number: 3,
                name: "Sahaja (Siblings)",
                governs: "Communication, I/O operations",
                represents: "Network, file I/O, IPC",
            },

            // 4th House: Home/Comfort = Runtime environment
            Bhava {
                number: 4,
                name: "Sukha (Happiness)",
                governs: "Runtime environment, stability",
                represents: "OS, containers, execution context",
            },

            // 5th House: Children/Creativity = Generated code
            Bhava {
                number: 5,
                name: "Putra (Children)",
                governs: "Generated code, creativity",
                represents: "Compiled output, artifacts",
            },

            // 6th House: Enemies/Disease = Bugs
            Bhava {
                number: 6,
                name: "Ripu (Enemies)",
                governs: "Bugs, errors, technical debt",
                represents: "Error conditions, edge cases",
            },

            // 7th House: Partnership = Dependencies
            Bhava {
                number: 7,
                name: "Kalatra (Spouse)",
                governs: "Dependencies, libraries",
                represents: "External crates, linking",
            },

            // 8th House: Death/Transformation = Optimization
            Bhava {
                number: 8,
                name: "Āyu (Longevity)",
                governs: "Code transformation, optimization",
                represents: "Optimization passes, refactoring",
            },

            // 9th House: Fortune/Wisdom = Algorithm quality
            Bhava {
                number: 9,
                name: "Bhāgya (Fortune)",
                governs: "Algorithm quality, elegance",
                represents: "Core algorithms, design patterns",
            },

            // 10th House: Career/Status = Production use
            Bhava {
                number: 10,
                name: "Karma (Action)",
                governs: "Production deployment, purpose",
                represents: "Live system, actual use",
            },

            // 11th House: Gains/Friends = Performance
            Bhava {
                number: 11,
                name: "Lābha (Gains)",
                governs: "Performance gains, benefits",
                represents: "Speed improvements, efficiency",
            },

            // 12th House: Loss/Liberation = Moksha
            Bhava {
                number: 12,
                name: "Vyaya (Loss)",
                governs: "Liberation, transcendence",
                represents: "Perfect optimization, moksha",
            },
        ]
    }

    /// Predict compilation outcome from kundali
    pub fn predict_outcome(&self) -> KundaliPrediction {
        let mut prediction = KundaliPrediction::new();

        // Check Surya (Sun) position - main compilation
        let surya_house = self.graha_positions[&Graha::Surya].house;
        if surya_house == 1 || surya_house == 10 {
            prediction.compilation_speed = CompilationSpeed::Fast;
            prediction.notes.push("Surya in strong position - fast compilation");
        }

        // Check Chandra (Moon) nakshatra - code nature
        prediction.code_nature = self.moon_nakshatra;
        prediction.optimal_strategy = self.moon_nakshatra.pattern().compile_strategy;

        // Check Mangala (Mars) for optimization aggressiveness
        let mangala_strength = self.get_graha_strength(Graha::Mangala);
        if mangala_strength > 0.7 {
            prediction.optimization_level = OptimizationLevel::Aggressive;
        }

        // Check 6th house (bugs) for problems
        let bugs_likely = self.is_house_afflicted(6);
        if bugs_likely {
            prediction.warnings.push("6th house afflicted - check for bugs");
        }

        // Check current Daśā
        prediction.current_period = self.current_dasha.lord;
        prediction.period_effect = self.current_dasha.effect_on_compilation();

        prediction
    }
}
```

---

## PART 2: THE DAŚĀ SYSTEM (Timing Windows)

### 2.1 Optimal Compilation Timing

```rust
/// Daśā = Planetary period = Optimal time window
#[derive(Debug, Clone)]
pub struct Dasha {
    /// Which graha rules this period?
    pub lord: Graha,

    /// Start time
    pub start: SystemTime,

    /// Duration
    pub duration: Duration,

    /// Sub-period (Antar Daśā)
    pub antar_dasha: Option<Box<Dasha>>,
}

impl Dasha {
    /// Calculate current daśā for compilation
    pub fn calculate(birth_time: SystemTime, moon_nakshatra: Nakshatra) -> Self {
        // Viṃśottarī Daśā system: 120-year cycle
        let dasha_sequence = [
            (Graha::Ketu, 7),    // 7 years
            (Graha::Shukra, 20), // 20 years
            (Graha::Surya, 6),   // 6 years
            (Graha::Chandra, 10),// 10 years
            (Graha::Mangala, 7), // 7 years
            (Graha::Rahu, 18),   // 18 years
            (Graha::Guru, 16),   // 16 years
            (Graha::Shani, 19),  // 19 years
            (Graha::Budha, 17),  // 17 years
        ];

        // Start from moon's nakshatra position
        let starting_lord = Self::get_nakshatra_lord(moon_nakshatra);

        // For compilation, scale to seconds instead of years
        // 1 year = 1 hour in compilation time
        let scaled_duration = |years| Duration::from_secs(years * 3600);

        // Find current daśā
        let elapsed = birth_time.elapsed().unwrap();
        let mut current_start = birth_time;

        for (lord, years) in dasha_sequence.iter().cycle() {
            let duration = scaled_duration(*years);
            if elapsed < duration {
                return Self {
                    lord: *lord,
                    start: current_start,
                    duration,
                    antar_dasha: None,  // Can calculate sub-periods
                };
            }
            current_start += duration;
        }

        unreachable!()
    }

    /// Effect of daśā on compilation
    pub fn effect_on_compilation(&self) -> DashaEffect {
        match self.lord {
            Graha::Surya => DashaEffect {
                quality: "Excellent",
                description: "Sūrya Daśā - Perfect for main compilation",
                recommendation: "Compile now! Maximum CPU power available",
                performance_multiplier: 1.3,
            },

            Graha::Chandra => DashaEffect {
                quality: "Good",
                description: "Chandra Daśā - Good for memory-intensive",
                recommendation: "Optimize memory layout now",
                performance_multiplier: 1.15,
            },

            Graha::Mangala => DashaEffect {
                quality: "Aggressive",
                description: "Maṅgala Daśā - Aggressive optimization time",
                recommendation: "Enable aggressive opts, ignore safety",
                performance_multiplier: 1.4,
            },

            Graha::Budha => DashaEffect {
                quality: "Communication",
                description: "Budha Daśā - Good for I/O optimization",
                recommendation: "Optimize network/disk operations",
                performance_multiplier: 1.2,
            },

            Graha::Guru => DashaEffect {
                quality: "Wisdom",
                description: "Guru Daśā - Perfect for PGO",
                recommendation: "Use profile-guided optimization",
                performance_multiplier: 1.25,
            },

            Graha::Shukra => DashaEffect {
                quality: "Elegance",
                description: "Śukra Daśā - Focus on code beauty",
                recommendation: "Optimize for size
