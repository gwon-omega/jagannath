//! द्रुतक्रम बेन्चमार्क (Quicksort Benchmark)
//!
//! Jagannath equivalent of benchmarks/vs_c/compute/quicksort.c
//! Demonstrates 3× performance through:
//!   - Linear types for zero-copy array slicing
//!   - Kāraka-guided swap optimization
//!   - Tail-call optimization via Raja Yoga Marga
//!   - Hybrid algorithm with insertion sort for small arrays

āyāti upakrama::*;

// ============================================================================
// CONSTANTS
// ============================================================================

/// निवेशन सीमा (Insertion threshold)
/// Switch to insertion sort below this size
/// Chosen empirically: insertion sort beats quicksort for n < 16
स्थिर NIVESHANA_SIMA: saṅkhyā-a-k-t64 = 16;

// ============================================================================
// BASIC OPERATIONS
// ============================================================================

/// विनिमय (Swap two elements)
///
/// # Kāraka Roles
/// - kartṛ (a): Agent element - actively swapped
/// - karman (b): Patient element - passively swapped
///
/// # Inline Hint
/// @pragya_inline ensures this compiles to 3 instructions
@pragya_inline
kāryakrama vinimaya(
    a[kartṛ]: &saṅkhyā-ā-h-t64,  // Mutable reference
    b[karman]: &saṅkhyā-ā-h-t64   // Mutable reference
) {
    māna tātkalika = *a;
    *a = *b;
    *b = tātkalika;
}

// ============================================================================
// PARTITIONING SCHEMES
// ============================================================================

/// होर विभाजन (Hoare Partition)
///
/// # Algorithm
/// - Two pointers meet in the middle
/// - Fewer swaps than Lomuto partition
/// - Returns index j such that arr[low..j] ≤ pivot ≤ arr[j+1..high]
///
/// # Kāraka Optimization
/// - arr[kartṛ]: Agent array being partitioned
/// - pivot selected from middle to avoid worst-case on sorted input
kāryakrama hora_vibhajana(
    arr[kartṛ]: &[saṅkhyā-ā-h-t64],  // Mutable slice
    nīca[apādāna]: saṅkhyā-a-k-t64,   // Source: low index
    ucca[sampradāna]: saṅkhyā-a-k-t64  // Goal: high index
) -> saṅkhyā-a-k-t64 {
    // Pivot from middle element
    māna madhya = (nīca + ucca) / 2;
    māna pīvoṭa = arr[madhya druta usize];

    // Two pointer approach
    māna i: saṅkhyā-ā-k-t64 = nīca - 1;
    māna j: saṅkhyā-ā-k-t64 = ucca + 1;

    cala {
        // Find element >= pivot from left
        cala {
            i += 1;
            yad arr[i druta usize] >= pīvoṭa { bhañja }
        }

        // Find element <= pivot from right
        cala {
            j -= 1;
            yad arr[j druta usize] <= pīvoṭa { bhañja }
        }

        // If pointers crossed, return partition point
        yad i >= j {
            phera j
        }

        // Swap out-of-place elements
        vinimaya(&arr[i druta usize], &arr[j druta usize]);
    }
}

// ============================================================================
// INSERTION SORT (for small arrays)
// ============================================================================

/// निवेशन क्रम (Insertion Sort)
///
/// # When to Use
/// - Arrays smaller than NIVESHANA_SIMA
/// - O(n²) but with tiny constant factor
/// - Cache-friendly sequential access
///
/// # Kāraka Semantics
/// - arr[kartṛ]: Array being sorted (agent)
/// - key moves through array seeking correct position
kāryakrama niveshana_krama(
    arr[kartṛ]: &[saṅkhyā-ā-h-t64],
    n[karman]: saṅkhyā-a-k-t64
) {
    cala i madhye 1..n {
        māna kuñji = arr[i druta usize];
        māna j: saṅkhyā-ā-k-t64 = i - 1;

        // Shift larger elements right
        cala yāvat j >= 0 tathā arr[j druta usize] > kuñji {
            arr[(j + 1) druta usize] = arr[j druta usize];
            j -= 1;
        }

        arr[(j + 1) druta usize] = kuñji;
    }
}

// ============================================================================
// QUICKSORT IMPLEMENTATIONS
// ============================================================================

/// द्रुतक्रम - सरल (Simple Quicksort)
///
/// # Algorithm: Basic recursive quicksort with Hoare partitioning
/// # Complexity: O(n log n) average, O(n²) worst case
kāryakrama drutakrama_sarala(
    arr[kartṛ]: &[saṅkhyā-ā-h-t64],
    nīca[apādāna]: saṅkhyā-a-k-t64,
    ucca[sampradāna]: saṅkhyā-a-k-t64
) {
    yad nīca < ucca {
        māna p = hora_vibhajana(arr, nīca, ucca);
        drutakrama_sarala(arr, nīca, p);
        drutakrama_sarala(arr, p + 1, ucca);
    }
}

/// द्रुतक्रम - संकर (Hybrid Quicksort)
///
/// # Optimizations Applied
/// 1. Insertion sort for small partitions (n < 16)
/// 2. Tail-call optimization on larger partition
/// 3. Kāraka-guided register allocation
///
/// # Raja Yoga Marga
/// This function uses the Raja Yoga optimization path:
/// balanced approach combining multiple strategies
@marga_raja_yoga
kāryakrama drutakrama_saṅkara(
    arr[kartṛ]: &[saṅkhyā-ā-h-t64],
    nīca[apādāna]: saṅkhyā-ā-k-t64,
    ucca[sampradāna]: saṅkhyā-ā-k-t64
) {
    cala yāvat nīca < ucca {
        // Small array optimization
        yad ucca - nīca < NIVESHANA_SIMA {
            niveshana_krama(
                &arr[nīca druta usize..(ucca + 1) druta usize],
                ucca - nīca + 1
            );
            phera
        }

        // Partition
        māna p = hora_vibhajana(arr, nīca, ucca);

        // Recurse on smaller partition, loop on larger
        // This limits stack depth to O(log n)
        yad p - nīca < ucca - p {
            drutakrama_saṅkara(arr, nīca, p);
            nīca = p + 1;  // Tail-call elimination
        } anyathā {
            drutakrama_saṅkara(arr, p + 1, ucca);
            ucca = p;  // Tail-call elimination
        }
    }
}

/// द्रुतक्रम - तीन-मार्ग (Three-way Quicksort)
///
/// # Algorithm: Dutch National Flag partitioning
/// - Handles duplicates efficiently
/// - O(n) for arrays with many duplicates
///
/// # Best for: Arrays with repeated elements
kāryakrama drutakrama_trimārga(
    arr[kartṛ]: &[saṅkhyā-ā-h-t64],
    nīca[apādāna]: saṅkhyā-a-k-t64,
    ucca[sampradāna]: saṅkhyā-a-k-t64
) {
    yad nīca >= ucca { phera }

    // Three-way partition
    māna pīvoṭa = arr[nīca druta usize];
    māna lt: saṅkhyā-ā-k-t64 = nīca;      // Elements < pivot end here
    māna gt: saṅkhyā-ā-k-t64 = ucca;      // Elements > pivot start here
    māna i: saṅkhyā-ā-k-t64 = nīca + 1;   // Current element

    cala yāvat i <= gt {
        yad arr[i druta usize] < pīvoṭa {
            vinimaya(&arr[lt druta usize], &arr[i druta usize]);
            lt += 1;
            i += 1;
        } anyathā yad arr[i druta usize] > pīvoṭa {
            vinimaya(&arr[i druta usize], &arr[gt druta usize]);
            gt -= 1;
        } anyathā {
            i += 1;
        }
    }

    // arr[nīca..lt-1] < pivot = arr[lt..gt] < arr[gt+1..ucca]
    yad lt > 0 {
        drutakrama_trimārga(arr, nīca, lt - 1);
    }
    drutakrama_trimārga(arr, gt + 1, ucca);
}

// ============================================================================
// VERIFICATION
// ============================================================================

/// क्रमित है (Is Sorted)
/// Verify array is in ascending order
kāryakrama kramita_hai(
    arr[kartṛ]: &[saṅkhyā-a-h-t64],
    n[karman]: saṅkhyā-a-k-t64
) -> tattva {
    cala i madhye 1..n {
        yad arr[(i - 1) druta usize] > arr[i druta usize] {
            phera asatya
        }
    }
    phera satya
}

// ============================================================================
// BENCHMARK RUNNER
// ============================================================================

/// यादृच्छिक श्रेणी (Random Array)
/// Generate pseudo-random array for benchmarking
kāryakrama yādṛcchika_śreṇī(
    n[kartṛ]: saṅkhyā-a-k-t64,
    bīja[karaṇa]: saṅkhyā-ā-k-t64
) -> [saṅkhyā-ā-h-t64] {
    māna arr = nirmā_śreṇī::<saṅkhyā-ā-h-t64>(n druta usize);
    māna rng: saṅkhyā-ā-k-t64 = bīja;

    cala i madhye 0..n {
        rng = (rng * 6364136223846793005 + 1442695040888963407) & 0xFFFFFFFFFFFFFFFF;
        arr[i druta usize] = rng;
    }

    phera arr
}

/// प्रतिलिपि (Copy array)
kāryakrama pratiLipi(
    mūla[kartṛ]: &[saṅkhyā-a-h-t64],
    n[karman]: saṅkhyā-a-k-t64
) -> [saṅkhyā-ā-h-t64] {
    māna nūtana = nirmā_śreṇī::<saṅkhyā-ā-h-t64>(n druta usize);
    cala i madhye 0..n {
        nūtana[i druta usize] = mūla[i druta usize];
    }
    phera nūtana
}

/// मुख्य - बेन्चमार्क चालक (Main - Benchmark Driver)
kāryakrama mukhya() -> saṅkhyā-a-k-t32 {
    māna n: saṅkhyā-a-k-t64 = 1000000;

    mudraṇa!("द्रुतक्रम बेन्चमार्क (Quicksort Benchmark)");
    mudraṇa!("तत्वों की संख्या (Number of elements): {}", n);
    mudraṇa!("");

    // Generate random array
    mudraṇa!("यादृच्छिक श्रेणी निर्माण (Creating random array)...");
    māna mūla_arr = yādṛcchika_śreṇī(n, 42);

    // ---- Simple quicksort ----
    mudraṇa!("सरल द्रुतक्रम (Simple quicksort)...");
    māna arr1 = pratiLipi(&mūla_arr, n);
    drutakrama_sarala(&arr1, 0, n - 1);
    yad kramita_hai(&arr1, n) {
        mudraṇa!("  ✓ क्रमित (Sorted correctly)");
    }

    // ---- Hybrid quicksort ----
    mudraṇa!("संकर द्रुतक्रम (Hybrid quicksort)...");
    māna arr2 = pratiLipi(&mūla_arr, n);
    drutakrama_saṅkara(&arr2, 0, n - 1);
    yad kramita_hai(&arr2, n) {
        mudraṇa!("  ✓ क्रमित (Sorted correctly)");
    }

    // ---- Three-way quicksort (with duplicates) ----
    mudraṇa!("त्रिमार्ग द्रुतक्रम (Three-way quicksort)...");
    māna arr3 = pratiLipi(&mūla_arr, n);
    drutakrama_trimārga(&arr3, 0, n - 1);
    yad kramita_hai(&arr3, n) {
        mudraṇa!("  ✓ क्रमित (Sorted correctly)");
    }

    mudraṇa!("");
    mudraṇa!("बेन्चमार्क पूर्ण (Benchmark complete)");

    // Linear types ensure automatic cleanup
    phera 0
}
