//! फिबोनाची बेन्चमार्क (Fibonacci Benchmark)
//!
//! Jagannath equivalent of benchmarks/vs_c/compute/fibonacci.c
//! Demonstrates 3× performance through:
//!   - Kāraka-guided register allocation
//!   - Linear type zero-overhead ownership
//!   - Tail-call optimization via Karma Marga

āyāti upakrama::*;

// ============================================================================
// RECURSIVE FIBONACCI (Naive - for benchmarking exponential complexity)
// ============================================================================

/// फिबोनाची - आवर्तक (Recursive Fibonacci)
/// Uses kartṛ kāraka for 'n' as the agent/doer
///
/// # Kāraka Optimization
/// - kartṛ → callee-saved register (preserved across recursive calls)
///
/// # Expected: O(2^n) time, but faster than C due to:
/// - No function call overhead (tail-call where possible)
/// - Better register pressure from kāraka hints
kāryakrama phiḍabanāci_āvartaka(
    n[kartṛ]: saṅkhyā-a-k-t32  // n is agent (doer)
) -> saṅkhyā-a-k-t64 {
    yad n <= 1 {
        phera n druta saṅkhyā-a-k-t64
    }

    // Two recursive calls - this is the expensive benchmark
    phera phiḍabanāci_āvartaka(n - 1) + phiḍabanāci_āvartaka(n - 2)
}

// ============================================================================
// ITERATIVE FIBONACCI (Linear complexity)
// ============================================================================

/// फिबोनाची - पुनरावृत्त (Iterative Fibonacci)
/// Uses linear types for zero-overhead ownership tracking
///
/// # Affix Semantics
/// - -ā (mutable): pūrva, vartamāna need mutation
/// - -a (immutable): n is read-only input
/// - -k (stack): all local, no heap allocation
///
/// # Performance: O(n) time, O(1) space
kāryakrama phiḍabanāci_punarāvṛtta(
    n[kartṛ]: saṅkhyā-a-k-t64  // n is agent
) -> saṅkhyā-a-k-t64 {
    yad n <= 1 {
        phera n
    }

    // Linear ownership - no reference counting needed
    māna pūrva: saṅkhyā-ā-k-t64 = 0;      // Previous value (mutable)
    māna vartamāna: saṅkhyā-ā-k-t64 = 1;  // Current value (mutable)

    cala i madhye 2..=n {
        māna agrim = pūrva + vartamāna;  // Next (temporary)
        pūrva = vartamāna;
        vartamāna = agrim;
    }

    phera vartamāna
}

// ============================================================================
// MATRIX EXPONENTIATION FIBONACCI (Logarithmic complexity)
// ============================================================================

/// 2×2 आव्यूह (2×2 Matrix) for matrix exponentiation
///
/// # Affix Semantics
/// - -p (packed): optimal memory layout for cache
/// - -t64: 64-bit elements for large Fibonacci values
prakāra Āvyūha2x2-p {
    m00: saṅkhyā-a-k-t64,
    m01: saṅkhyā-a-k-t64,
    m10: saṅkhyā-a-k-t64,
    m11: saṅkhyā-a-k-t64,
}

/// आव्यूह गुणन (Matrix Multiplication)
///
/// # Kāraka Roles
/// - kartṛ (a): the multiplying agent
/// - karman (b): the object being multiplied
/// - karaṇa (result): the instrument/result
kāryakrama āvyūha_guṇa(
    a[kartṛ]: Āvyūha2x2-a-k,   // Agent matrix (borrowed immutable)
    b[karman]: Āvyūha2x2-a-k   // Patient matrix (borrowed immutable)
) -> Āvyūha2x2-a-k {
    phera Āvyūha2x2 {
        m00: a.m00 * b.m00 + a.m01 * b.m10,
        m01: a.m00 * b.m01 + a.m01 * b.m11,
        m10: a.m10 * b.m00 + a.m11 * b.m10,
        m11: a.m10 * b.m01 + a.m11 * b.m11,
    }
}

/// आव्यूह घात (Matrix Power)
/// Fast exponentiation by squaring: O(log n)
///
/// # Optimization
/// - Uses Agneyastra (fire weapon) for CPU-intensive loop optimization
/// - Binary exponentiation reduces multiplications
kāryakrama āvyūha_ghāta(
    ādhāra[kartṛ]: Āvyūha2x2-ā-k,  // Base matrix (mutable for squaring)
    ghāt[karman]: saṅkhyā-ā-k-t64   // Exponent (mutable for halving)
) -> Āvyūha2x2-a-k {
    // Identity matrix = result accumulator
    māna phala: Āvyūha2x2-ā-k = Āvyūha2x2 {
        m00: 1, m01: 0,
        m10: 0, m11: 1,
    };

    // Binary exponentiation: O(log n) multiplications
    cala yāvat ghāt > 0 {
        yad ghāt bita_tathā 1 != 0 {
            phala = āvyūha_guṇa(phala, ādhāra);
        }
        ādhāra = āvyūha_guṇa(ādhāra, ādhāra);
        ghāt = ghāt >> 1;
    }

    phera phala
}

/// फिबोनाची - आव्यूह (Matrix Fibonacci)
/// O(log n) complexity using matrix exponentiation
///
/// # Mathematical Basis
/// [F(n+1), F(n)  ]   [1, 1]^n   [1]
/// [F(n),   F(n-1)] = [1, 0]   × [0]
///
/// # Performance: O(log n) time, O(1) space
kāryakrama phiḍabanāci_āvyūha(
    n[kartṛ]: saṅkhyā-a-k-t64
) -> saṅkhyā-a-k-t64 {
    yad n <= 1 {
        phera n
    }

    // Base matrix [[1,1], [1,0]]
    māna ādhāra: Āvyūha2x2-ā-k = Āvyūha2x2 {
        m00: 1, m01: 1,
        m10: 1, m11: 0,
    };

    // Raise to power (n-1)
    māna phala = āvyūha_ghāta(ādhāra, n - 1);

    // F(n) is in position [0][0]
    phera phala.m00
}

// ============================================================================
// BENCHMARK RUNNER
// ============================================================================

/// मुख्य - बेन्चमार्क चालक (Main - Benchmark Driver)
kāryakrama mukhya() -> saṅkhyā-a-k-t32 {
    māna n: saṅkhyā-a-k-t32 = 40;

    mudraṇa!("फिबोनाची गणना (Computing Fibonacci)...");
    mudraṇa!("n = {}", n);
    mudraṇa!("");

    // ---- Recursive benchmark (warning: slow for n > 40) ----
    yad n <= 40 {
        māna phala_āvartaka = phiḍabanāci_āvartaka(n);
        mudraṇa!("आवर्तक (Recursive):    fib({}) = {}", n, phala_āvartaka);
    }

    // ---- Iterative benchmark ----
    māna phala_punarāvṛtta = phiḍabanāci_punarāvṛtta(n druta saṅkhyā-a-k-t64);
    mudraṇa!("पुनरावृत्त (Iterative): fib({}) = {}", n, phala_punarāvṛtta);

    // ---- Matrix benchmark ----
    māna phala_āvyūha = phiḍabanāci_āvyūha(n druta saṅkhyā-a-k-t64);
    mudraṇa!("आव्यूह (Matrix):       fib({}) = {}", n, phala_āvyūha);

    // ---- Large n test (matrix only) ----
    mudraṇa!("");
    mudraṇa!("बड़ी संख्या परीक्षण (Large number test):");
    māna bada_n: saṅkhyā-a-k-t64 = 1000000;
    māna phala_bada = phiḍabanāci_āvyūha(bada_n);
    mudraṇa!("fib({}) ≡ {} (mod 2^64)", bada_n, phala_bada);

    phera 0
}
