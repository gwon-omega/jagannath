# Jagannath v3.0 Patch Specification
## Hindu Philosophy Integration Layer

**Version:** 3.0.0-philosophy
**Date:** December 26, 2024
**Patch Type:** Major Feature Addition
**Dependencies:** Requires v2.0 (Assembly Backend)
**Status:** Implementation Ready

---

## PATCH OVERVIEW

This patch adds a complete **Hindu philosophy layer** on top of the existing Jagannath compiler (v1.0 Sanskrit morphology + v2.0 Assembly backend), implementing:

1. **Nyāya Logic System** - 4-pramāṇa type inference
2. **Sāṃkhya Tattva Pipeline** - 25-stage compilation hierarchy
3. **Advaita Memory Model** - Unified heap with type overlays
4. **Pancha Kosha Memory** - 5-tier memory hierarchy
5. **Guṇa Optimization** - 3-mode compilation profiles
6. **Kāla Time Budgets** - Compile-time vs runtime prioritization
7. **Karma Dependency** - Causal dependency tracking

**Expected Performance Gain:** 60-90% over v2.0 baseline
**New Code:** ~35,000 lines Rust + ~5,000 lines Jagannath stdlib

---

## FILE STRUCTURE (NEW FILES ONLY)

```
jagannath/
├── compiler/
│   ├── philosophy/                    # NEW MODULE (v3.0)
│   │   ├── mod.rs                     # Philosophy integration entry
│   │   │
│   │   ├── nyaya/                     # Nyāya logic system
│   │   │   ├── mod.rs
│   │   │   ├── pramana.rs            # 4 pramāṇa definitions
│   │   │   ├── pratyaksha.rs         # Direct perception (explicit types)
│   │   │   ├── anumana.rs            # Inference engine
│   │   │   ├── upamana.rs            # Pattern matching
│   │   │   └── shabda.rs             # Contract/documentation validation
│   │   │
│   │   ├── samkhya/                   # Sāṃkhya 25 tattvas
│   │   │   ├── mod.rs
│   │   │   ├── tattvas.rs            # 25 tattva definitions
│   │   │   ├── purusha.rs            # Level 25 - Source intent
│   │   │   ├── prakriti.rs           # Level 24 - AST potential
│   │   │   ├── buddhi.rs             # Level 23 - Semantic analysis
│   │   │   ├── ahamkara.rs           # Level 22 - Symbol table
│   │   │   ├── manas.rs              # Level 21 - IR generation
│   │   │   ├── indriyas.rs           # Levels 20-11 - I/O faculties
│   │   │   ├── tanmatras.rs          # Levels 10-6 - Subtle elements
│   │   │   └── mahabhutas.rs         # Levels 5-1 - Gross elements
│   │   │
│   │   ├── advaita/                   # Advaita non-duality
│   │   │   ├── mod.rs
│   │   │   ├── brahman_memory.rs     # Unified memory allocator
│   │   │   ├── maya_overlay.rs       # Type system as illusion
│   │   │   └── atman_optimization.rs # Identity-based optimizations
│   │   │
│   │   ├── pancha_kosha/              # 5 bodies memory model
│   │   │   ├── mod.rs
│   │   │   ├── annamaya.rs           # Physical - Register/L1
│   │   │   ├── pranamaya.rs          # Vital - L2/L3 cache
│   │   │   ├── manomaya.rs           # Mental - RAM
│   │   │   ├── vijnanamaya.rs        # Wisdom - Disk/persistent
│   │   │   └── anandamaya.rs         # Bliss - Network/distributed
│   │   │
│   │   ├── guna/                      # 3 guṇa optimization modes
│   │   │   ├── mod.rs
│   │   │   ├── sattva.rs             # Purity - correctness-first
│   │   │   ├── rajas.rs              # Activity - speed-first
│   │   │   └── tamas.rs              # Inertia - memory-first
│   │   │
│   │   ├── kala/                      # Time dilation/budgets
│   │   │   ├── mod.rs
│   │   │   ├── brahma_time.rs        # Compile-time (infinite budget)
│   │   │   ├── manushya_time.rs      # Runtime (normal)
│   │   │   └── kshana_time.rs        # Critical path (instant)
│   │   │
│   │   └── karma/                     # Causation/dependency
│   │       ├── mod.rs
│   │       ├── dependency_graph.rs   # Karma chain tracking
│   │       ├── samsara.rs            # Recompilation cycles
│   │       └── moksha.rs             # Pure functions (no deps)
│   │
│   └── semantics/
│       └── philosophy_integration.rs  # Bridge to existing semantic pass
│
├── stdlib/
│   └── darshana/                      # Philosophy library (NEW)
│       ├── nyaya.jag                  # Nyāya logic utilities
│       ├── samkhya.jag                # Tattva introspection
│       ├── advaita.jag                # Memory unity helpers
│       └── yoga.jag                   # Karma tracking API
│
├── docs/
│   ├── philosophy/                    # NEW DOCUMENTATION
│   │   ├── nyaya_guide.md            # Pramāṇa type system guide
│   │   ├── samkhya_pipeline.md       # Tattva compilation stages
│   │   ├── advaita_memory.md         # Unified heap model
│   │   ├── pancha_kosha.md           # 5-tier memory guide
│   │   └── hindu_concepts.md         # Complete philosophy reference
│   │
│   └── migration/
│       └── v2_to_v3_upgrade.md       # Migration guide
│
└── examples/
    └── philosophy/                    # NEW EXAMPLES
        ├── nyaya_inference.jag        # Type inference demo
        ├── samkhya_stages.jag         # Compilation stage demo
        ├── advaita_polymorphism.jag   # Unified memory demo
        ├── kosha_allocation.jag       # 5-tier memory demo
        └── guna_optimization.jag      # 3-mode optimization demo
```

---

## PART 1: NYĀYA LOGIC SYSTEM

### 1.1 New Affixes for Pramāṇas

**File: `compiler/philosophy/nyaya/pramana.rs`**

```rust
/// Nyāya pramāṇa (means of valid knowledge) markers
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Pramana {
    /// Pratyakṣa - Direct perception (explicit annotation)
    Pratyaksha,   // Suffix: -pratyakṣa

    /// Anumāna - Inference (logical deduction)
    Anumana,      // Suffix: -anumāna

    /// Upamāna - Comparison (pattern matching)
    Upamana,      // Suffix: -upamāna

    /// Śabda - Testimony (documentation/contract)
    Shabda,       // Suffix: -śabda
}

/// Map pramāṇa to certainty level
impl Pramana {
    pub fn certainty(&self) -> f32 {
        match self {
            Pramana::Pratyaksha => 1.0,   // 100% certain (explicit)
            Pramana::Anumana => 0.95,     // 95% certain (inferred)
            Pramana::Upamana => 0.85,     // 85% certain (analogous)
            Pramana::Shabda => 0.90,      // 90% certain (documented)
        }
    }
}
```

### 1.2 Syntax Extensions

**NEW: Pramāṇa Type Annotations**

```sanskrit
# 1. PRATYAKṢA (Explicit - highest certainty)
saṅkhyā-pratyakṣa-k: t32 = 42;
# Compiler: Direct observation, 100% certain

# 2. ANUMĀNA (Inferred - logical deduction)
saṅkhyā-anumāna-k = 42;
# Compiler infers: "Must be t32 because literal 42 fits t32"

# 3. UPAMĀNA (Pattern match - by analogy)
kāryakrama yojana-upamāna<T>(x: T, y: T) -> T {
    # T inferred by upamāna: both params must match
    phera x + y;
}

# 4. ŚABDA (Contract - documentation authority)
kāryakrama-śabda gaṇana(
    sūci: Sūci<t32>-b
) -> t64-k
yatra sūci.dairghya > 0,    # Precondition (śabda pramāṇa)
      phala >= 0             # Postcondition (śabda pramāṇa)
{
    soma-k: t64 = 0;
    cala x : sūci → { soma += x; }
    phera soma;
}
```

### 1.3 Implementation

**File: `compiler/philosophy/nyaya/anumana.rs`**

```rust
/// Anumāna inference engine
pub struct AnumanaInference {
    /// Known facts (hetu - evidence)
    facts: Vec<Fact>,

    /// Inference rules (vyāpti - invariable relation)
    rules: Vec<InferenceRule>,
}

impl AnumanaInference {
    /// Perform anumāna (inference) to determine type
    pub fn infer_type(&self, expr: &Expr) -> Option<Type> {
        // Classic Nyāya inference (5-step syllogism):
        // 1. Pratijñā (Proposition): "x has type T"
        // 2. Hetu (Reason): "because x is used as T"
        // 3. Udāharaṇa (Example): "like other T values"
        // 4. Upanaya (Application): "x is similar"
        // 5. Nigamana (Conclusion): "therefore x: T"

        for rule in &self.rules {
            if let Some(hetu) = self.find_evidence(expr) {
                if rule.applies(hetu) {
                    return Some(rule.conclude_type());
                }
            }
        }
        None
    }
}

/// Vyāpti - Universal relation (like "where smoke, there fire")
pub struct InferenceRule {
    pub condition: Box<dyn Fn(&Expr) -> bool>,
    pub conclusion: Type,
    pub vyapti: String,  // The universal relation
}
```

### 1.4 Error Messages (NEW)

```
Error: Cannot determine type for `x`

Attempted pramāṇas (means of knowledge):
  × Pratyakṣa (Direct): No explicit type annotation
  × Anumāna (Inference): Insufficient evidence at line 42
    Evidence found: x used in arithmetic
    Cannot conclude: Could be t32, t64, or f32
  × Upamāna (Analogy): No matching pattern
    Similar expressions: None in scope
  × Śabda (Testimony): No documentation contract

Suggestion: Add explicit type (pratyakṣa pramāṇa)
  Help: x-pratyakṣa-k: t32 = ...
```

---

## PART 2: SĀṂKHYA TATTVA PIPELINE

### 2.1 25 Tattva Definitions

**File: `compiler/philosophy/samkhya/tattvas.rs`**

```rust
/// Sāṃkhya tattva - Principle of manifestation
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Tattva {
    // Level 25-24: Unmanifest
    Purusha = 25,        // Pure consciousness (source code intent)
    Prakriti = 24,       // Primordial matter (AST potential)

    // Level 23-21: Cognitive faculties
    Buddhi = 23,         // Intellect (semantic analysis)
    Ahamkara = 22,       // Ego-sense (symbol table/naming)
    Manas = 21,          // Mind (IR generation)

    // Level 20-16: Sensory faculties (Jñānendriyas)
    Shrotra = 20,        // Hearing (lexical analysis)
    Tvak = 19,           // Touch (syntax validation)
    Chakshu = 18,        // Sight (AST construction)
    Rasana = 17,         // Taste (semantic checking)
    Ghrana = 16,         // Smell (pattern recognition)

    // Level 15-11: Action faculties (Karmendriyas)
    Vak = 15,            // Speech (code emission)
    Pani = 14,           // Hands (manipulation)
    Pada = 13,           // Feet (traversal)
    Payu = 12,           // Excretion (cleanup)
    Upastha = 11,        // Generation (output)

    // Level 10-6: Subtle elements (Tanmātras)
    Shabda = 10,         // Sound essence (tokens)
    Sparsha = 9,         // Touch essence (syntax)
    Rupa = 8,            // Form essence (structure)
    Rasa = 7,            // Taste essence (semantics)
    Gandha = 6,          // Smell essence (patterns)

    // Level 5-1: Gross elements (Mahābhūtas)
    Akasha = 5,          // Space (memory layout)
    Vayu = 4,            // Air (control flow)
    Tejas = 3,           // Fire (computation)
    Apas = 2,            // Water (data flow)
    Prithivi = 1,        // Earth (machine code - final)
}

impl Tattva {
    /// Get cache key for this tattva stage
    pub fn cache_key(&self) -> String {
        format!("tattva_{:02}", *self as u8)
    }

    /// Can we restart compilation from this tattva?
    pub fn is_cacheable(&self) -> bool {
        match self {
            Tattva::Buddhi | Tattva::Manas | Tattva::Akasha => true,
            _ => false,
        }
    }
}
```

### 2.2 Syntax Extensions

```sanskrit
# Tattva-level compilation control

# Compile to specific tattva level only
saṃkalana-tattva(source.jag, tattva: Buddhi) {
    # Stop at semantic analysis, cache result
}

# Resume from cached tattva
saṃkalana-punah(cache: Buddhi-cache) -> Prithivi {
    # Resume from IR, skip earlier stages
}

# Introspect compilation stage
tattva-darśana-k() {
    yad saṃkalana-sthiti {
        | Purusha → mudraṇa("Parsing source"),
        | Buddhi → mudraṇa("Analyzing semantics"),
        | Prithivi → mudraṇa("Generating assembly")
    }
}
```

### 2.3 Implementation

**File: `compiler/philosophy/samkhya/mod.rs`**

```rust
/// Sāṃkhya-based compilation pipeline
pub struct SamkhyaCompiler {
    /// Current tattva (stage of manifestation)
    current_tattva: Tattva,

    /// Cached intermediate results (saṃskāra - impressions)
    tattva_cache: HashMap<Tattva, CachedResult>,

    /// Evolution path (prakṛti vikāra)
    evolution_path: Vec<Tattva>,
}

impl SamkhyaCompiler {
    /// Evolve from puruṣa (source) to pṛthivī (machine code)
    pub fn evolve(&mut self, source: SourceCode) -> MachineCode {
        let mut state = CompilationState::Purusha(source);

        for tattva in Self::tattva_sequence() {
            // Check cache (saṃskāra - past impressions)
            if let Some(cached) = self.tattva_cache.get(&tattva) {
                if cached.is_valid() {
                    state = cached.state.clone();
                    continue;
                }
            }

            // Evolve to next tattva (vikāra - transformation)
            state = self.transform(state, tattva);

            // Cache if tattva is stable
            if tattva.is_cacheable() {
                self.tattva_cache.insert(tattva, CachedResult {
                    state: state.clone(),
                    timestamp: SystemTime::now(),
                });
            }
        }

        self.extract_machine_code(state)
    }

    /// 25-stage tattva sequence
    fn tattva_sequence() -> Vec<Tattva> {
        (1..=25).rev().map(|n| Tattva::from_level(n)).collect()
    }
}
```

---

## PART 3: ADVAITA UNIFIED MEMORY

### 3.1 New Memory Model

**File: `compiler/philosophy/advaita/brahman_memory.rs`**

```rust
/// Advaita principle: All memory is manifestation of Brahman
/// Types are māyā (illusion) - overlays on unified reality
pub struct BrahmanHeap {
    /// The one reality (Brahman) - unified memory pool
    brahman: Vec<u8>,

    /// Nāma-rūpa (name-form) - illusory type distinctions
    nama_rupa_table: HashMap<TypeId, NamaRupa>,

    /// Witness (sākṣī) - metadata for allocations
    witness: AllocationRegistry,
}

/// Nāma-rūpa - Name and form (apparent distinction)
pub struct NamaRupa {
    pub name: String,      // Type name (nāma)
    pub layout: Layout,    // Memory form (rūpa)
    pub is_maya: bool,     // Is this a projected type?
}

impl BrahmanHeap {
    /// Allocate - all allocations from same Brahman
    pub fn allocate<T>(&mut self, value: T) -> BrahmanPtr<T> {
        let offset = self.brahman.len();
        self.brahman.extend_from_slice(to_bytes(&value));

        BrahmanPtr {
            brahman_offset: offset,
            type_overlay: PhantomData,  // Type is māyā
        }
    }

    /// Advaita optimization: recognize underlying unity
    pub fn unify_compatible_types(&mut self) {
        // If two types have identical layout, treat as same reality
        for (ty1, layout1) in &self.nama_rupa_table {
            for (ty2, layout2) in &self.nama_rupa_table {
                if ty1 != ty2 && layout1.layout == layout2.layout {
                    // Mark as unified (same Brahman, different māyā)
                    self.mark_unified(ty1, ty2);
                }
            }
        }
    }
}

/// Pointer with type overlay (pratibhāsa - apparent form)
pub struct BrahmanPtr<T> {
    brahman_offset: usize,        // Position in unified reality
    type_overlay: PhantomData<T>, // Illusory type distinction
}

impl<T> BrahmanPtr<T> {
    /// Advaita transmutation: change māyā (type view) without changing Brahman
    pub fn transmute_view<U>(self) -> BrahmanPtr<U>
    where
        Layout<T>: CompatibleWith<Layout<U>>
    {
        BrahmanPtr {
            brahman_offset: self.brahman_offset,  // Same reality
            type_overlay: PhantomData,             // Different illusion
        }
    }
}
```

### 3.2 Syntax Extensions

```sanskrit
# Advaita memory annotations

# Vyavahārika level (empirical - appears distinct)
prakāra Upayoktṛ-vyavahārika-p = {
    id: t64-k, nāma: Sūtra-a
}

# Paramārthika level (absolute - compiler sees unity)
prakāra Grāhaka-paramārthika-p = {
    id: t64-k, viṣayavastu: Sūtra-a
}

# Advaita optimization hint
kāryakrama-advaita prakriyā(x: Upayoktṛ-b, y: Grāhaka-b) {
    # Compiler recognizes: same layout = same Brahman
    # Can optimize as single code path
    yad x.id == y.id → {
        # Zero-cost comparison (same reality)
    }
}

# Explicit transmutation (safe type view change)
māyā-pariṇāma<T, U>(ptr: BrahmanPtr<T>) -> BrahmanPtr<U>
yatra Layout<T> == Layout<U>  # Compiler verifies compatibility
{
    # Change type view without copying data
    phera ptr as BrahmanPtr<U>;
}
```

---

## PART 4: PANCHA KOSHA MEMORY TIERS

### 4.1 5-Body Memory Hierarchy

**File: `compiler/philosophy/pancha_kosha/mod.rs`**

```rust
/// Pancha Kosha - 5 sheaths/bodies memory model
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Kosha {
    /// Annamaya - Physical body (most gross)
    Annamaya = 1,    // Register/L1 cache - fastest

    /// Prāṇamaya - Vital/energy body
    Pranamaya = 2,   // L2/L3 cache - fast

    /// Manomaya - Mental body
    Manomaya = 3,    // RAM - working memory

    /// Vijñānamaya - Wisdom body
    Vijnanamaya = 4, // Disk - persistent storage

    /// Ānandamaya - Bliss body (most subtle)
    Anandamaya = 5,  // Network/cloud - boundless
}

impl Kosha {
    /// Get optimal memory location for this kosha
    pub fn memory_location(&self) -> MemoryLocation {
        match self {
            Kosha::Annamaya => MemoryLocation::Register,
            Kosha::Pranamaya => MemoryLocation::L2Cache,
            Kosha::Manomaya => MemoryLocation::RAM,
            Kosha::Vijnanamaya => MemoryLocation::Disk,
            Kosha::Anandamaya => MemoryLocation::Network,
        }
    }

    /// Access latency for this kosha
    pub fn latency_cycles(&self) -> u64 {
        match self {
            Kosha::Annamaya => 1,       // 1 cycle (register)
            Kosha::Pranamaya => 10,     // 10 cycles (L2)
            Kosha::Manomaya => 100,     // 100 cycles (RAM)
            Kosha::Vijnanamaya => 10_000_000, // 10M cycles (disk)
            Kosha::Anandamaya => 100_000_000,  // 100M cycles (network)
        }
    }
}

/// Kosha-aware allocation strategy
pub struct KoshaAllocator {
    /// Heat map: track access frequency
    access_counts: HashMap<Symbol, u64>,

    /// Current placement
    placements: HashMap<Symbol, Kosha>,
}

impl KoshaAllocator {
    /// Migrate data between koshas based on access patterns
    pub fn optimize_placement(&mut self) {
        for (symbol, count) in &self.access_counts {
            let current_kosha = self.placements[symbol];
            let optimal_kosha = self.infer_kosha(*count);

            if optimal_kosha < current_kosha {
                // Move to inner kosha (faster access)
                self.migrate(symbol, optimal_kosha);
            } else if optimal_kosha > current_kosha {
                // Move to outer kosha (free up fast memory)
                self.migrate(symbol, optimal_kosha);
            }
        }
    }

    fn infer_kosha(&self, access_count: u64) -> Kosha {
        match access_count {
            1000.. => Kosha::Annamaya,      // Very hot → register
            100..=999 => Kosha::Pranamaya,  // Hot → cache
            10..=99 => Kosha::Manomaya,     // Warm → RAM
            2..=9 => Kosha::Vijnanamaya,    // Cold → disk
            0..=1 => Kosha::Anandamaya,     // Frozen → network
        }
    }
}
```

### 4.2 Syntax Extensions

```sanskrit
# Pancha Kosha memory tier annotations

# Annamaya (physical - register/L1)
gaṇaka-anna-k: t64 = 0;
cala i : 0..1000000 → {
    gaṇaka-anna += i;  # Hot loop counter in register
}

# Prāṇamaya (vital - L2/L3 cache)
bufara-prana-k: [4096] = śūnya;
# Cache-aligned buffer for hot data

# Manomaya (mental - RAM)
upayoktṛ-manas-l^1 = nirmā^1(Upayoktṛ { ... });
# User object in working memory

# Vijñānamaya (wisdom - disk/persistent)
dattakoṣa-vijnana-h = Dattakoṣa-kholana("/data/users.db");
# Database on persistent storage

# Ānandamaya (bliss - network/cloud)
sevā-ananda-g-sūtra = Http-sevā-prārambha("0.0.0.0:8080");
# Network service (boundless, distributed)

# Automatic migration hint
sañcaya-kosha-svachalita-k = [1000];
# Compiler migrates between koshas based on access pattern
```

---

## PART 5: GUṆA OPTIMIZATION MODES

### 5.1 Three Quality Profiles

**File: `compiler/philosophy/guna/mod.rs`**

```rust
/// Guṇa - Quality/mode of optimization
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Guna {
    /// Sattva - Purity, goodness
    Sattva,  // Correctness-first, formal verification

    /// Rajas - Passion, activity
    Rajas,   // Speed-first, aggressive optimization

    /// Tamas - Darkness, inertia
    Tamas,   // Memory-first, minimal resource use
}

impl Guna {
    /// Optimization strategy for this guṇa
    pub fn optimization_strategy(&self) -> OptimizationStrategy {
        match self {
            Guna::Sattva => OptimizationStrategy {
                inline_threshold: 50,      // Conservative inlining
                unroll_loops: false,       // Preserve structure
                bounds_checks: true,       // Always verify
                overflow_checks: true,     // Safety first
                assertions: true,          // Keep all assertions
                optimization_level: 1,     // Moderate optimization
            },

            Guna::Rajas => OptimizationStrategy {
                inline_threshold: 1000,    // Aggressive inlining
                unroll_loops: true,        // Unroll everything
                bounds_checks: false,      // Assume valid
                overflow_checks: false,    // Trust programmer
                assertions: false,         // Remove all asserts
                optimization_level: 3,     // Maximum optimization
            },

            Guna::Tamas => OptimizationStrategy {
                inline_threshold: 10,      // Minimal inlining
                unroll_loops: false,       // No unrolling
                bounds_checks: true,       // Safety retained
                overflow_checks: true,     // Errors detected
                assertions: true,          // Debugging enabled
                optimization_level: 0,     // Size optimization
            },
        }
    }
}
```

### 5.2 Syntax Extensions

```sanskrit
# Guṇa-based optimization markers

# SATTVA (correctness-first)
kāryakrama-sattva saṃkalana-surakṣita(a: t32-k, b: t32-k) -> t32-k {
    # Verified correct, may be slower
    # Overflow checks, bounds checks, assertions
    phera a + b;
}

# RAJAS (speed-first)
kāryakrama-rajas saṃkalana-druta(a: t32-k, b: t32-k) -> t32-k {
    # Maximum speed, assumes valid input
    # No checks, aggressive inline, loop unrolling
    phera a + b;
}

# TAMAS (memory-first)
kāryakrama-tamas saṃkalana-laghu(a: t32-k, b: t32-k) -> t32-k {
    # Minimum memory footprint
    # Reuse registers, no stack allocation, size-optimized
    phera a + b;
}

# Mixed guṇa per function
kāryakrama prakriyā-miśra(
    x: t32-sattva-k,  # This param needs safety
    y: t32-rajas-k    # This param needs speed
) -> t32-tamas-l {   # Return needs small size
    phera (x + y);
}
```

---

## PART 6: KĀLA TIME BUDGETS

### 6.1 Time Dilation System

**File: `compiler/philosophy/kala/mod.rs`**

```rust
/// Kāla - Time scale (Hindu cosmological time)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Kala {
    /// Brahma-kāla - Day of Brahma (eons)
    Brahma,  // Compile-time (infinite budget)

    /// Manuṣya-kāla - Human time (years)
    Manushya, // Runtime (normal)

    /// Kṣaṇa-kāla - Moment (microseconds)
    Kshana,  // Critical path (instant)
}

impl Kala {
    /// Compilation time budget for this kāla
    pub fn compile_time_budget(&self) -> Option<Duration> {
        match self {
            Kala::Brahma => None,                    // Unlimited
            Kala::Manushya => Some(Duration::from_secs(60)),  // 1 minute
            Kala::Kshana => Some(Duration::from_millis(100)), // 100ms
        }
    }

    /// Optimization aggressiveness
    pub fn optimization_priority(&self) -> u8 {
        match self {
            Kala::Brahma => 10,   // Maximum - spend all time optimizing
            Kala::Manushya => 5,  // Moderate - balance compile vs runtime
            Kala::Kshana => 10,   // Maximum - critical path needs best code
        }
    }
}
```

### 6.2 Syntax Extensions

```sanskrit
# Kāla time budget markers

# BRAHMA-KĀLA (compile-time - infinite budget)
gaṇana-kāla-brahma#(n: t32) -> t32 {
    # Complex computation at compile time
    # Compiler can spend minutes optimizing
    phera factorial(n) * fibonacci(n);
}

# Usage: result is constant-folded
pariṇāma-k: t32 = gaṇana-kāla-brahma#(20);  # Computed during compilation

# MANUṢYA-KĀLA (runtime - normal)
kāryakrama-kāla-manushya prakriyā(dattā: Bufara-b) {
    # Normal runtime code
    # Standard optimization (O2)
}

# KṢAṆA-KĀLA (critical path - instant)
kāryakrama-kāla-kshana tikshna-mārga(x: t64-k) -> t64-k {
    # Latency-critical hot path
    # Aggressive: inline, unroll, vectorize, no bounds checks
    phera x * x + 1;
}

# Mixed time scales
kāryakrama prakriyā-kāla-miśra() {
    # Slow setup (brahma-kāla at compile time)
    sthira-dattā# = load_configuration#();

    # Normal processing (manuṣya-kāla)
    dattā = paṭha-kośa("input.txt");

    # Hot loop (kṣaṇa-kāla)
    cala paṅkti : dattā → {
        prakriyā-kāla-kshana(paṅkti);
    }
}
```

---

## PART 7: KARMA DEPENDENCY TRACKING

### 7.1 Causation Model

**File: `compiler/philosophy/karma/dependency_graph.rs`**

```rust
/// Karma - Action and its consequence (causation)
pub struct KarmaGraph {
    /// Nodes: compilation units (functions, modules)
    nodes: HashMap<NodeId, KarmaNode>,

    /// Edges: causal dependencies (karma-phala)
    edges: HashMap<NodeId, Vec<KarmaDependency>>,

    /// Saṃskāra: past compilations (impressions)
    samskaras: HashMap<NodeId, CompiledArtifact>,
}

/// Karma node: source of action
pub struct KarmaNode {
    pub id: NodeId,
    pub source: PathBuf,
    pub last_modified: SystemTime,
    pub karma_type: KarmaType,
}

/// Type of karma (action)
#[derive(Debug, Clone, Copy)]
pub enum KarmaType {
    /// Śuddha karma - Pure (no side effects)
    Shuddha,  // Pure function - no recompilation deps

    /// Miśra karma - Mixed (some side effects)
    Mishra,   // Normal function - local deps

    /// Aśuddha karma - Impure (many side effects)
    Ashuddha, // Impure function - global deps
}

impl KarmaGraph {
    /// Determine recompilation karma (ripple effect)
    pub fn propagate_karma(&self, changed: NodeId) -> Vec<NodeId> {
        let mut affected = Vec::new();
        let mut queue = vec![changed];
        let mut visited = HashSet::new();

        while let Some(node) = queue.pop() {
            if visited.contains(&node) {
                continue;
            }
            visited.insert(node);

            // Find all nodes dependent on this (karma-phala chain)
            if let Some(deps) = self.edges.get(&node) {
                for dep in deps {
                    affected.push(dep.target);
                    queue.push(dep.target);
                }
            }
        }

        affected
    }

    /// Check if function achieved mokṣa (liberation from recompilation)
    pub fn is_moksha(&self, node: NodeId) -> bool {
        let karma_node = &self.nodes[&node];

        // Mokṣa = pure function with no dependencies
        matches!(karma_node.karma_type, KarmaType::Shuddha)
            && self.edges.get(&node).map_or(true, |deps| deps.is_empty())
    }
}
```

### 7.2 Syntax Extensions

```sanskrit
# Karma dependency annotations

# ŚUDDHA KARMA (pure - no side effects, attained mokṣa)
kāryakrama-mokṣa śuddha-gaṇana(x: t32-k) -> t32-k {
    # Pure function, no karma accumulation
    # Never needs recompilation unless signature changes
    phera x + 1;
}

# MIŚRA KARMA (mixed - local side effects)
kāryakrama-miśra prakriyā-sthānīya(x: t32-ā) {
    # Modifies local state
    # Recompilation if dependencies change
    x += 1;
}

# AŚUDDHA KARMA (impure - global side effects)
kāryakrama-ashuddha prakriyā-sarvatra(dattā: Bufara-b) {
    # Side effects: I/O, global state
    # Triggers wide recompilation ripples
    kośa-lekhana("output.txt", dattā);
    SARVATRA-GAṆAKA += 1;  # Global mutation
}

# Karma introspection
karma-darśana(kāryakrama-nāma: Sūtra-b) -> KarmaPrakāra {
    # Query karma type of function
    phera compiler.karma_graph.get_karma_type(kāryakrama-nāma);
}

# Saṃsāra (rebirth) - recompilation cycle
yad karma-parivartana("module.jag") → {
    # File changed, determine rebirth (recompilation) scope
    punarjanma-sūci = karma-praṇālikā.pracāraṇa("module.jag");
    mudraṇa("Recompiling {} files due to karma", punarjanma-sūci.dairghya);
}
```

---

## INTEGRATION GUIDE

### Step 1: Update Compiler Architecture

**File: `compiler/src/main.rs`** (MODIFY)

```rust
// Add philosophy module
mod philosophy {
    pub mod nyaya;
    pub mod samkhya;
    pub mod advaita;
    pub mod pancha_kosha;
    pub mod guna;
    pub mod kala;
    pub mod karma;
}

use philosophy::*;

fn main() {
    let mut compiler = JagannathCompiler::new();

    // Initialize v3.0 philosophy layer
    compiler.enable_nyaya_inference();      // 4-pramāṇa type system
    compiler.enable_samkhya_pipeline();     // 25-tattva caching
    compiler.enable_advaita_memory();       // Unified heap
    compiler.enable_kosha_tiers();          // 5-tier memory
    compiler.enable_guna_profiles();        // 3-mode optimization
    compiler.enable_kala_budgets();         // Time dilation
    compiler.enable_karma_tracking();       // Dependency graph

    compiler.compile(args.input);
}
```

### Step 2: Extend Affix Parser

**File: `compiler/lexer/affixes.rs`** (ADD)

```rust
// v3.0 philosophy affixes
pub const PHILOSOPHY_AFFIXES: &[&str] = &[
    // Nyāya pramāṇas
    "-pratyakṣa", "-anumāna", "-upamāna", "-śabda",

    // Sāṃkhya tattvas
    "-puruṣa", "-prakṛti", "-buddhi", "-ahaṃkāra", "-manas",
    "-ākāśa", "-vāyu", "-tejas", "-āpas", "-pṛthivī",

    // Advaita
    "-vyavahārika", "-paramārthika", "-māyā", "-brahman",

    // Pancha Kosha
    "-anna", "-prāṇa", "-manas-kosha", "-vijñāna", "-ānanda",

    // Guṇas
    "-sattva", "-rajas", "-tamas",

    // Kāla
    "-kāla-brahma", "-kāla-manuṣya", "-kāla-kṣaṇa",

    // Karma
    "-mokṣa", "-śuddha", "-miśra", "-aśuddha",
];
```

### Step 3: Update Type System

**File: `compiler/semantics/typeck.rs`** (MODIFY)

```rust
use crate::philosophy::nyaya::NyayaTypeChecker;

pub struct TypeChecker {
    // Existing fields...

    // NEW: v3.0 philosophy integration
    nyaya: NyayaTypeChecker,
}

impl TypeChecker {
    pub fn infer_type(&mut self, expr: &Expr) -> Result<Type, TypeError> {
        // Try v3.0 Nyāya 4-pramāṇa inference first
        if let Some(ty) = self.nyaya.infer_with_pramanas(expr) {
            return Ok(ty);
        }

        // Fall back to v2.0 affix-based inference
        self.infer_from_affixes(expr)
    }
}
```

---

## TESTING REQUIREMENTS

### Unit Tests (NEW)

**File: `compiler/philosophy/tests/nyaya_tests.rs`**

```rust
#[test]
fn test_pratyaksha_inference() {
    let source = "x-pratyakṣa-k: t32 = 42;";
    let ty = infer_type(source);
    assert_eq!(ty.pramana, Pramana::Pratyaksha);
    assert_eq!(ty.base_type, BaseType::T32);
}

#[test]
fn test_anumana_inference() {
    let source = "x-anumāna-k = 42;";
    let ty = infer_type(source);
    assert_eq!(ty.pramana, Pramana::Anumana);
    assert_eq!(ty.base_type, BaseType::T32);
}

#[test]
fn test_tattva_caching() {
    let mut compiler = SamkhyaCompiler::new();

    // First compilation - full pipeline
    let result1 = compiler.compile("test.jag");
    assert!(compiler.tattva_cache.contains_key(&Tattva::Buddhi));

    // Second compilation - use cache
    let result2 = compiler.compile("test.jag");
    assert_eq!(result1, result2);
    assert!(compiler.used_cache);
}
```

### Integration Tests (NEW)

**File: `tests/philosophy_integration.rs`**

```rust
#[test]
fn test_kosha_memory_placement() {
    let source = r#"
        gaṇaka-anna-k: t64 = 0;
        bufara-prāṇa-k: [4096];
        upayoktṛ-manas-l^1 = nirmā^1(Upayoktṛ);
    "#;

    let compiled = compile(source);

    // Verify memory placement
    assert_eq!(compiled.find_symbol("gaṇaka").location, Location::Register);
    assert_eq!(compiled.find_symbol("bufara").location, Location::L2Cache);
    assert_eq!(compiled.find_symbol("upayoktṛ").location, Location::RAM);
}

#[test]
fn test_guna_optimization() {
    let sattva = compile_with_guna("fn() { x + y }", Guna::Sattva);
    let rajas = compile_with_guna("fn() { x + y }", Guna::Rajas);

    // Sattva has bounds checks, Rajas doesn't
    assert!(sattva.has_bounds_checks());
    assert!(!rajas.has_bounds_checks());

    // Rajas is faster but less safe
    assert!(rajas.runtime() < sattva.runtime());
}
```

---

## PERFORMANCE BENCHMARKS (NEW)

**File: `benchmarks/philosophy/nyaya_bench.rs`**

```rust
#[bench]
fn bench_pratyaksha_vs_anumana(b: &mut Bencher) {
    let explicit = "x-pratyakṣa-k: t32 = 42;";
    let inferred = "x-anumāna-k = 42;";

    b.iter(|| {
        let t1 = compile_and_time(explicit);
        let t2 = compile_and_time(inferred);

        // Pratyakṣa should be faster (direct)
        assert!(t1 < t2);
    });
}

#[bench]
fn bench_tattva_caching(b: &mut Bencher) {
    b.iter(|| {
        let mut compiler = SamkhyaCompiler::new();

        let t1 = time(|| compiler.compile("test.jag"));
        let t2 = time(|| compiler.compile("test.jag"));  // Uses cache

        // Second compilation should be 50%+ faster
        assert!(t2.as_millis() < t1.as_millis() / 2);
    });
}

#[bench]
fn bench_advaita_polymorphism(b: &mut Bencher) {
    let advaita_code = "fn(x: Any-brahman) { x.method() }";
    let traditional_code = "fn<T>(x: T) { x.method() }";

    b.iter(|| {
        let t1 = runtime_benchmark(advaita_code);
        let t2 = runtime_benchmark(traditional_code);

        // Advaita should be 30%+ faster (unified memory)
        assert!(t1.as_nanos() < t2.as_nanos() * 70 / 100);
    });
}
```

---

## MIGRATION FROM v2.0 TO v3.0

### Backward Compatibility

**All v2.0 code continues to work unchanged**

```sanskrit
# v2.0 code (still works)
upayoktṛ-ā-l-p^1 = nirmā^1(Upayoktṛ);

# v3.0 enhanced (optional)
upayoktṛ-ā-l-p-manas^1 = nirmā^1(Upayoktṛ);
#                 ^^^^^^ NEW: kosha tier annotation
```

### Opt-in Philosophy Features

```toml
# Cargo.toml or patra.toml
[features]
default = []

# Enable v3.0 features individually
nyaya = []
samkhya = []
advaita = []
pancha-kosha = []
guna = []
kala = []
karma = []

# Enable all philosophy features
philosophy-full = [
    "nyaya",
    "samkhya",
    "advaita",
    "pancha-kosha",
    "guna",
    "kala",
    "karma"
]
```

### Compiler Flags

```bash
# Compile with v2.0 semantics (default)
jagc source.jag -o output

# Enable v3.0 philosophy layer
jagc source.jag -o output --philosophy

# Enable specific features
jagc source.jag --nyaya --samkhya
jagc source.jag --advaita --kosha
jagc source.jag --guna=rajas  # Force rajas mode
```

---

## DOCUMENTATION UPDATES

### New User-Facing Docs

1. **`docs/philosophy/nyaya_guide.md`**
   - Explain 4 pramāṇas
   - When to use each
   - Error message interpretation

2. **`docs/philosophy/samkhya_pipeline.md`**
   - 25 tattva stages explained
   - Caching strategies
   - Incremental build optimization

3. **`docs/philosophy/advaita_memory.md`**
   - Unified heap model
   - Type transmutation
   - Performance benefits

4. **`docs/philosophy/pancha_kosha.md`**
   - 5-tier memory hierarchy
   - Automatic migration
   - Manual placement hints

5. **`docs/philosophy/optimization_modes.md`**
   - Guṇa profiles comparison
   - Kāla time budgets
   - When to use each mode

### Updated Existing Docs

- **`README.md`**: Add v3.0 features section
- **`CHANGELOG.md`**: Document all v3.0 additions
- **`docs/language_reference.md`**: Add philosophy affix table

---

## EXPECTED PERFORMANCE GAINS (v2.0 → v3.0)

```
Feature                      | Compilation Speed | Runtime Speed | Memory Usage
====================================================================================
Nyāya inference              | +30%             | 0%            | 0%
Sāṃkhya tattva caching       | +50% (incr.)     | 0%            | 0%
Advaita unified memory       | 0%               | +30%          | -10%
Pancha Kosha tiers           | 0%               | +20%          | -15%
Guṇa optimization (rajas)    | 0%               | +40%          | 0%
Kāla budgets (brahma#)       | Special          | +50% (const)  | 0%
Karma dependency tracking    | +25% (incr.)     | 0%            | 0%
====================================================================================
COMBINED IMPACT              | +60%             | +90%          | -20%
```

### Real-World Benchmarks (Predicted)

```
Application                  | v2.0   | v3.0   | Improvement
================================================================
Embedded sensor (MCU)        | 16 KB  | 11 KB  | 31% less RAM
Neural net inference (CPU)   | 9 ms   | 5 ms   | 44% faster
HTTP server (10K conn)       | 140 MB | 100 MB | 29% less memory
Compilation (10K LOC)        | 5s     | 2s     | 60% faster compile
JSON parser (10 MB)          | 1.9s   | 1.0s   | 47% faster
```

---

## ROLLOUT PLAN

### Phase 1 (Month 1): Nyāya + Sāṃkhya
- Implement 4-pramāṇa type inference
- Implement 25-tattva pipeline with caching
- **Goal:** 50% faster incremental builds

### Phase 2 (Month 2): Advaita + Kosha
- Implement unified Brahman heap
- Implement 5-tier kosha memory model
- **Goal:** 30% faster runtime, 15% less memory

### Phase 3 (Month 3): Guṇa + Kāla + Karma
- Implement 3 guṇa optimization modes
- Implement kāla time budgets
- Implement karma dependency tracking
- **Goal:** Full philosophy layer complete

### Phase 4 (Month 4): Testing + Documentation
- Comprehensive test suite
- Performance benchmarking
- User documentation
- Migration guide

### Release: v3.0.0 (End of Month 4)
- Stable philosophy layer
- Opt-in by default
- Full backward compatibility

---

## SUMMARY FOR VS CODE IMPLEMENTATION

### Critical Files to Create (Priority Order)

1. **`compiler/philosophy/nyaya/anumana.rs`** - Type inference engine
2. **`compiler/philosophy/samkhya/tattvas.rs`** - Pipeline stages
3. **`compiler/philosophy/advaita/brahman_memory.rs`** - Unified heap
4. **`compiler/philosophy/pancha_kosha/mod.rs`** - 5-tier allocator
5. **`compiler/philosophy/guna/mod.rs`** - Optimization modes
6. **`compiler/semantics/philosophy_integration.rs`** - Bridge layer

### Integration Points (Modify Existing)

1. **`compiler/lexer/affixes.rs`** - Add philosophy affixes
2. **`compiler/semantics/typeck.rs`** - Hook Nyāya inference
3. **`compiler/mir/optimize.rs`** - Add guṇa/kāla passes
4. **`compiler/codegen/asm/register_alloc.rs`** - Use kosha hints

### New Syntax Keywords

```sanskrit
# Pramāṇas
-pratyakṣa, -anumāna, -upamāna, -śabda

# Tattvas (select)
-puruṣa, -buddhi, -manas, -pṛthivī

# Advaita
-vyavahārika, -paramārthika

# Koshas
-anna, -prāṇa, -manas, -vijñāna, -ānanda

# Guṇas
-sattva, -rajas, -tamas

# Kāla
-kāla-brahma#, -kāla-manuṣya, -kāla-kṣaṇa

# Karma
-mokṣa, -śuddha, -miśra, -aśuddha
```

### Compiler Flags (NEW)

```bash
--philosophy          # Enable all v3.0 features
--nyaya              # Enable Nyāya inference
--samkhya            # Enable Sāṃkhya caching
--advaita            # Enable Advaita memory
--kosha              # Enable Kosha tiers
--guna=<mode>        # Set guṇa mode (sattva/rajas/tamas)
--kala-budget=<ms>   # Set compilation time budget
```

---

**END OF v3.0 PATCH SPECIFICATION**

**Total New Code:** ~35,000 lines Rust + ~5,000 lines Jagannath
**Expected Performance:** 1.9× faster than C (up from 1.3× in v2.0)
**Timeline:** 4 months for full implementation
**Status:** Ready for implementation

*"अद्वैतं संस्कृतं च - एकत्र युक्तम्"*
*("Non-duality and Sanskrit - united as one")*
