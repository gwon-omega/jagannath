# Jagannath v5.0 Patch Specification
## Garuda Purana: Forensic Error Classification & Security Framework

**Version:** 5.0.0-garuda-narakas
**Date:** December 27, 2024
**Patch Type:** Major Security & Error Handling System
**Dependencies:** Requires v4.0 (Yoga & Philosophy Integration)
**Status:** Implementation Ready

---

## PATCH OVERVIEW

This patch implements **Garuda Purana's 28 Narakas (Hells)** as a comprehensive **compiler error taxonomy, security violation detection, and resource punishment system**, including:

1. **28 Naraka Error Types** - Precise classification of all possible violations
2. **Yama Dharmaraja Judge** - Static analysis engine that determines violations
3. **Chitragupta Records** - Complete audit trail (build logs/forensics)
4. **Vaitarani Security Boundary** - Untrusted→Trusted transition enforcement
5. **Preta State Detection** - Resource leak identification
6. **Yamadutas Enforcement** - Automated violation detection agents
7. **Karma-Phala Taint Analysis** - Sin propagation through call chains
8. **Moksha Redemption** - How to fix violations and achieve liberation

**Expected Impact:** 80-95% reduction in runtime errors, **zero-trust security model**, perfect audit compliance
**New Code:** ~28,000 lines Rust + ~6,000 lines Jagannath stdlib

---

## PHILOSOPHICAL FOUNDATION

### Garuda Purana Core Principles

```
Principle                    | Compiler Application
=================================================================================
Yama judges based on karma   | Static analyzer judges code based on violations
28 Narakas for specific sins | 28 error categories for specific code violations
Chitragupta keeps records    | Complete build artifact audit trail
Punishment fits the crime    | Error severity matches violation severity
Temporary suffering          | Warnings vs errors vs critical security flaws
Liberation through penance   | Fix code to remove errors (achieve moksha)
Yamadutas enforce justice    | Automated linters/sanitizers/fuzzers
Vaitarani river crossing     | Security boundary enforcement
Preta (hungry ghost) state   | Resource leaks (allocated but never freed)
```

---

## FILE STRUCTURE (NEW FILES ONLY - v5.0)

```
jagannath/
├── compiler/
│   ├── garuda/                        # NEW MODULE (v5.0)
│   │   ├── mod.rs
│   │   │
│   │   ├── narakas/                   # 28 Hell classifications
│   │   │   ├── mod.rs
│   │   │   ├── tamisram.rs           # Hell 1: Stealing (memory theft)
│   │   │   ├── andhatamisram.rs      # Hell 2: Betrayal (API contract violation)
│   │   │   ├── raurava.rs            # Hell 3: Violence (crashes/panics)
│   │   │   ├── maharaurava.rs        # Hell 4: Killing (process termination)
│   │   │   ├── kumbhipaka.rs         # Hell 5: Cooking sins (resource exhaustion)
│   │   │   ├── kalasutra.rs          # Hell 6: Thread torture (deadlocks)
│   │   │   ├── asipatravana.rs       # Hell 7: Sword forest (buffer overflow)
│   │   │   ├── sukaramukha.rs        # Hell 8: Pig-faced (code smell/dirty code)
│   │   │   ├── andhakupa.rs          # Hell 9: Dark well (null pointer)
│   │   │   ├── krimibhaksha.rs       # Hell 10: Worm-food (memory corruption)
│   │   │   ├── sandamsha.rs          # Hell 11: Tongs torture (race conditions)
│   │   │   ├── taptasurmi.rs         # Hell 12: Hot iron (type confusion)
│   │   │   ├── vajrakantaka.rs       # Hell 13: Diamond needles (unnatural access)
│   │   │   ├── vaitarani.rs          # Hell 14: Filth river (tainted data)
│   │   │   ├── puyoda.rs             # Hell 15: Pus well (data corruption)
│   │   │   ├── pranarodha.rs         # Hell 16: Breath stoppage (deadlock)
│   │   │   ├── visasana.rs           # Hell 17: Slaughter (forced termination)
│   │   │   ├── lalabhaksha.rs        # Hell 18: Semen sea (inappropriate data)
│   │   │   ├── sarameyadana.rs       # Hell 19: Dog-bite (wild pointer)
│   │   │   ├── avichi.rs             # Hell 20: Waveless (stack overflow)
│   │   │   ├── ayahpana.rs           # Hell 21: Drinking iron (poison data)
│   │   │   ├── ksharakardama.rs      # Hell 22: Salt mud (insecure storage)
│   │   │   ├── raksogana.rs          # Hell 23: Demon gang (malicious code)
│   │   │   ├── sulaprota.rs          # Hell 24: Spear (code injection)
│   │   │   ├── dandasuka.rs          # Hell 25: Biting snakes (logic errors)
│   │   │   ├── vatarodha.rs          # Hell 26: Weapon torture (DoS attack)
│   │   │   ├── paryavartana.rs       # Hell 27: Bird torture (resource denial)
│   │   │   └── suchimukha.rs         # Hell 28: Needle torture (memory leak)
│   │   │
│   │   ├── yama/                      # Judge & Enforcement
│   │   │   ├── mod.rs
│   │   │   ├── dharmaraja.rs         # Yama as static analyzer
│   │   │   ├── judgment.rs           # Violation severity determination
│   │   │   ├── yamadutas.rs          # Enforcement agents (linters)
│   │   │   └── sentence.rs           # Error message generation
│   │   │
│   │   ├── chitragupta/               # Audit & Records
│   │   │   ├── mod.rs
│   │   │   ├── records.rs            # Build artifact tracking
│   │   │   ├── karma_ledger.rs       # Violation history
│   │   │   └── audit_trail.rs        # Forensic logging
│   │   │
│   │   ├── vaitarani/                 # Security Boundaries
│   │   │   ├── mod.rs
│   │   │   ├── boundary.rs           # Untrusted→trusted transition
│   │   │   ├── purification.rs       # Sanitization functions
│   │   │   └── crossing_check.rs     # Validation enforcement
│   │   │
│   │   ├── preta/                     # Resource Leak Detection
│   │   │   ├── mod.rs
│   │   │   ├── hungry_ghost.rs       # Leak identification
│   │   │   ├── unfulfilled.rs        # Allocated but not freed
│   │   │   └── liberation.rs         # Fix suggestions
│   │   │
│   │   ├── taint/                     # Taint Analysis (Sin Propagation)
│   │   │   ├── mod.rs
│   │   │   ├── sin_tracking.rs       # Track tainted data flow
│   │   │   ├── propagation.rs        # How taint spreads
│   │   │   └── sanitizers.rs         # Cleansing functions
│   │   │
│   │   └── moksha/                    # Redemption System
│   │       ├── mod.rs
│   │       ├── penance.rs            # How to fix each naraka
│   │       ├── liberation.rs         # Achieving error-free state
│   │       └── quick_fixes.rs        # Auto-fix suggestions
│   │
│   └── security/                      # NEW MODULE
│       ├── mod.rs
│       ├── zero_trust.rs             # Zero-trust security model
│       ├── capability.rs             # Capability-based security
│       └── sandbox.rs                # Sandboxing untrusted code
│
├── stdlib/
│   └── garuda/                        # NEW LIBRARY
│       ├── naraka_types.jag          # Error type definitions
│       ├── yama_api.jag              # Judgment API
│       ├── vaitarani.jag             # Security boundary utilities
│       ├── preta_detect.jag          # Leak detection helpers
│       └── moksha.jag                # Error recovery patterns
│
├── docs/
│   └── garuda/                        # NEW DOCUMENTATION
│       ├── naraka_taxonomy.md        # Complete error classification
│       ├── yama_judgment.md          # How violations are detected
│       ├── vaitarani_boundaries.md   # Security boundaries guide
│       ├── preta_leaks.md            # Resource leak patterns
│       ├── taint_analysis.md         # Data flow security
│       └── moksha_fixes.md           # How to fix each error
│
└── examples/
    └── garuda/                        # NEW EXAMPLES
        ├── naraka_demo.jag           # Trigger each error type
        ├── vaitarani_crossing.jag    # Security boundary demo
        ├── preta_detection.jag       # Leak detection demo
        ├── taint_propagation.jag     # Taint tracking demo
        └── moksha_achievement.jag    # Error-free code example
```

---

## PART 1: 28 NARAKA ERROR TAXONOMY

### 1.1 Complete Classification System

**File: `compiler/garuda/narakas/mod.rs`**

```rust
/// Garuda Purana's 28 Narakas mapped to compiler errors
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Naraka {
    // MEMORY VIOLATIONS (Hells 1-10)

    /// 1. Tamisram - Heavy flogging
    /// Sin: Stealing others' wealth
    /// Code: Memory theft (use-after-free, double-free)
    Tamisram,

    /// 2. Andhatamisram - Darkness flogging
    /// Sin: Betraying spouse/partner
    /// Code: API contract violation, breaking promises
    Andhatamisram,

    /// 3. Raurava - Screaming
    /// Sin: Violence causing suffering
    /// Code: Panic/crash causing process death
    Raurava,

    /// 4. Maharaurava - Great screaming
    /// Sin: Killing living beings
    /// Code: Killing child processes, forced termination
    Maharaurava,

    /// 5. Kumbhipaka - Cooking in pot
    /// Sin: Cooking/boiling sins
    /// Code: Resource exhaustion (CPU/memory burning)
    Kumbhipaka,

    /// 6. Kalasutra - Black thread
    /// Sin: Disrespecting elders
    /// Code: Thread safety violations, deadlocks
    Kalasutra,

    /// 7. Asipatravana - Sword-leaf forest
    /// Sin: Abandoning dharma
    /// Code: Buffer overflow (sharp edges cut)
    Asipatravana,

    /// 8. Sukaramukha - Pig-faced
    /// Sin: Oppressing subjects (rulers)
    /// Code: Code smell, dirty/unmaintainable code
    Sukaramukha,

    /// 9. Andhakupa - Dark well
    /// Sin: Oppressing good people
    /// Code: Null pointer dereference (dark abyss)
    Andhakupa,

    /// 10. Krimibhaksha - Worm-eating
    /// Sin: Dishonoring guests
    /// Code: Memory corruption (worms eating data)
    Krimibhaksha,

    // CONCURRENCY VIOLATIONS (Hells 11-16)

    /// 11. Sandamsha - Tongs torture
    /// Sin: Adultery
    /// Code: Race condition (multiple access to same resource)
    Sandamsha,

    /// 12. Taptasurmi - Hot iron
    /// Sin: Unnatural intercourse
    /// Code: Type confusion, casting violations
    Taptasurmi,

    /// 13. Vajrakantaka - Diamond needles
    /// Sin: Intercourse with animals
    /// Code: Accessing foreign memory (FFI violations)
    Vajrakantaka,

    /// 14. Vaitarani - Filthy river
    /// Sin: Abusing power, adultery
    /// Code: Tainted data crossing security boundary
    Vaitarani,

    /// 15. Puyoda - Pus well
    /// Sin: Deceiving women, false promises
    /// Code: Data corruption, malformed structures
    Puyoda,

    /// 16. Pranarodha - Breath stoppage
    /// Sin: Imprisoning innocents
    /// Code: Deadlock (process cannot breathe/continue)
    Pranarodha,

    // SECURITY VIOLATIONS (Hells 17-23)

    /// 17. Visasana - Slaughterhouse
    /// Sin: Selling wife, imprisoning
    /// Code: Forced process termination, kill -9
    Visasana,

    /// 18. Lalabhaksha - Semen sea
    /// Sin: Lustful acts with wife
    /// Code: Inappropriate data exposure
    Lalabhaksha,

    /// 19. Sarameyadana - Dog-bite
    /// Sin: Poisoning food, mass slaughter
    /// Code: Wild pointer, dangling reference
    Sarameyadana,

    /// 20. Avichi - Waveless
    /// Sin: False witness, perjury
    /// Code: Stack overflow (no waves = no stack space)
    Avichi,

    /// 21. Ayahpana - Drinking molten iron
    /// Sin: Consuming alcohol
    /// Code: Consuming poisoned/malicious data
    Ayahpana,

    /// 22. Ksharakardama - Alkali mud
    /// Sin: Pride, false teaching
    /// Code: Insecure credential storage (plaintext passwords)
    Ksharakardama,

    /// 23. Raksogana - Demon gang
    /// Sin: Sacrificing humans/animals
    /// Code: Malicious code injection, RCE
    Raksogana,

    // RESOURCE VIOLATIONS (Hells 24-28)

    /// 24. Sulaprota - Spear impalement
    /// Sin: Killing animals for pleasure
    /// Code: Code injection attack (spear through body)
    Sulaprota,

    /// 25. Dandasuka - Snake biting
    /// Sin: Imprisoning/starving people
    /// Code: Logic error causing starvation (deadlock variant)
    Dandasuka,

    /// 26. Vatarodha - Weapon torture
    /// Sin: Persecuting forest animals
    /// Code: Denial of service attack
    Vatarodha,

    /// 27. Paryavartana - Bird torture
    /// Sin: Denying food to hungry
    /// Code: Resource denial (refusing allocation)
    Paryavartana,

    /// 28. Suchimukha - Needle torture
    /// Sin: Pride, miserliness, not repaying debts
    /// Code: Memory leak (allocated but never freed = unpaid debt)
    Suchimukha,
}

impl Naraka {
    /// Severity level (used for error reporting)
    pub fn severity(&self) -> Severity {
        match self {
            // CRITICAL - Security/Memory safety
            Raurava | Maharaurava | Vaitarani | Raksogana | Sulaprota
                => Severity::Critical,

            // ERROR - Will cause runtime failure
            Tamisram | Asipatravana | Andhakupa | Sandamsha | Avichi | Pranarodha
                => Severity::Error,

            // WARNING - Code smell, potential issue
            Andhatamisram | Sukaramukha | Krimibhaksha | Suchimukha
                => Severity::Warning,

            _ => Severity::Error,
        }
    }

    /// Punishment duration (how long error persists)
    pub fn duration(&self) -> Duration {
        match self.severity() {
            Severity::Critical => Duration::Permanent,  // Won't compile
            Severity::Error => Duration::UntilFixed,    // Blocks build
            Severity::Warning => Duration::Temporary,   // Can ignore
        }
    }

    /// Moksha path (how to fix)
    pub fn redemption_path(&self) -> &'static str {
        match self {
            Tamisram => "Use borrowed reference (-b) instead of stealing ownership",
            Andhakupa => "Add null check or use Option<T> type",
            Vaitarani => "Apply śuddhi-kri() sanitizer before crossing boundary",
            Suchimukha => "Call mukta() to free allocated memory",
            // ... etc for all 28
            _ => "See docs/garuda/moksha_fixes.md for guidance"
        }
    }
}
```

### 1.2 Error Message Format

```rust
/// Garuda-style error message
pub struct NarakaError {
    pub naraka: Naraka,
    pub location: Span,
    pub sin: String,          // What code did wrong
    pub punishment: String,   // Consequence (compiler action)
    pub penance: String,      // How to fix
}

impl Display for NarakaError {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "
╔═══════════════════════════════════════════════════════════════╗
║ NARAKA: {:?} ({})
║ LOCATION: {}:{}
╠═══════════════════════════════════════════════════════════════╣
║ SIN (Violation):
║   {}
║
║ PUNISHMENT (Consequence):
║   {}
║
║ PENANCE (Fix):
║   {}
╚═══════════════════════════════════════════════════════════════╝
",
            self.naraka,
            self.naraka.severity(),
            self.location.file,
            self.location.line,
            self.sin,
            self.punishment,
            self.penance
        )
    }
}
```

---

## PART 2: YAMA DHARMARAJA (Static Analyzer Judge)

### 2.1 Judgment System

**File: `compiler/garuda/yama/dharmaraja.rs`**

```rust
/// Yama Dharmaraja - Judge of the dead (code analyzer)
pub struct YamaDharmaraja {
    /// Chitragupta's records
    chitragupta: ChitraguptaRecords,

    /// Yamadutas (enforcement agents)
    yamadutas: Vec<Yamaduta>,

    /// Judgment criteria
    dharma_rules: Vec<DharmaRule>,
}

impl YamaDharmaraja {
    /// Judge code and assign to appropriate Naraka
    pub fn judge(&self, code: &AST) -> Vec<NarakaViolation> {
        let mut violations = Vec::new();

        // Dispatch Yamadutas to inspect code
        for yamaduta in &self.yamadutas {
            let findings = yamaduta.inspect(code);
            violations.extend(findings);
        }

        // Yama weighs good vs evil (correct code vs violations)
        for violation in &violations {
            let naraka = self.determine_naraka(violation);
            let sentence = self.pass_sentence(naraka, violation);

            // Record in Chitragupta's ledger
            self.chitragupta.record(violation, naraka, sentence);
        }

        violations
    }

    fn determine_naraka(&self, v: &Violation) -> Naraka {
        match v.kind {
            ViolationKind::UseAfterFree => Naraka::Tamisram,
            ViolationKind::NullDeref => Naraka::Andhakupa,
            ViolationKind::BufferOverflow => Naraka::Asipatravana,
            ViolationKind::Deadlock => Naraka::Kalasutra,
            ViolationKind::RaceCondition => Naraka::Sandamsha,
            ViolationKind::TaintedData => Naraka::Vaitarani,
            ViolationKind::MemoryLeak => Naraka::Suchimukha,
            ViolationKind::StackOverflow => Naraka::Avichi,
            ViolationKind::CodeInjection => Naraka::Sulaprota,
            ViolationKind::DoS => Naraka::Vatarodha,
            // ... all 28 mappings
            _ => Naraka::Raurava,  // Default to violence/crash
        }
    }
}
```

### 2.2 Yamadutas (Enforcement Agents)

**File: `compiler/garuda/yama/yamadutas.rs`**

```rust
/// Yamaduta - Enforcement agent (specialized linter)
pub trait Yamaduta {
    fn name(&self) -> &str;
    fn inspect(&self, code: &AST) -> Vec<Violation>;
}

/// Memory Yamaduta - Detects memory violations
pub struct MemoryYamaduta;
impl Yamaduta for MemoryYamaduta {
    fn inspect(&self, code: &AST) -> Vec<Violation> {
        let mut violations = Vec::new();

        // Check for use-after-free (Tamisram)
        for expr in code.all_expressions() {
            if self.is_use_after_free(expr) {
                violations.push(Violation {
                    kind: ViolationKind::UseAfterFree,
                    location: expr.span,
                    evidence: "Object used after ownership transferred".into(),
                });
            }
        }

        // Check for memory leaks (Suchimukha)
        for alloc in code.all_allocations() {
            if !self.has_corresponding_free(alloc) {
                violations.push(Violation {
                    kind: ViolationKind::MemoryLeak,
                    location: alloc.span,
                    evidence: "Allocation never freed (unpaid debt)".into(),
                });
            }
        }

        violations
    }
}

/// Security Yamaduta - Detects security violations
pub struct SecurityYamaduta;
impl Yamaduta for SecurityYamaduta {
    fn inspect(&self, code: &AST) -> Vec<Violation> {
        // Check for tainted data (Vaitarani)
        // Check for code injection (Sulaprota)
        // Check for insecure storage (Ksharakardama)
        // ...
    }
}

/// Concurrency Yamaduta - Detects thread violations
pub struct ConcurrencyYamaduta;
impl Yamaduta for ConcurrencyYamaduta {
    fn inspect(&self, code: &AST) -> Vec<Violation> {
        // Check for deadlocks (Kalasutra/Pranarodha)
        // Check for race conditions (Sandamsha)
        // ...
    }
}
```

---

## PART 3: VAITARANI SECURITY BOUNDARY

### 3.1 River Crossing Enforcement

**File: `compiler/garuda/vaitarani/boundary.rs`**

```rust
/// Vaitarani - Filthy river that must be crossed to enter trusted realm
/// In code: transition from untrusted → trusted data
pub struct VaitaraniBoundary {
    /// Untrusted sources (external input)
    untrusted_sources: HashSet<Symbol>,

    /// Purification functions (sanitizers)
    purifiers: HashMap<TypeId, PurificationFn>,
}

impl VaitaraniBoundary {
    /// Check if data can cross from untrusted → trusted
    pub fn can_cross(&self, data: &Expr) -> Result<(), VaitaraniViolation> {
        if self.is_tainted(data) {
            // Tainted data attempting crossing without purification
            Err(VaitaraniViolation {
                naraka: Naraka::Vaitarani,
                data: data.clone(),
                message: "Tainted data attempting Vaitarani crossing \
                          without śuddhi-kri() purification".into(),
                required_purifier: self.get_required_purifier(data),
            })
        } else {
            Ok(())
        }
    }

    /// Apply purification (sanitization)
    pub fn purify(&self, data: &mut Expr) -> Result<(), PurificationError> {
        let purifier = self.purifiers.get(&data.type_id())
            .ok_or(PurificationError::NoPurifierFound)?;

        purifier(data)?;

        // Mark as clean (crossed Vaitarani successfully)
        data.mark_as_trusted();
        Ok(())
    }
}

/// Taint analysis - track sin propagation
pub struct TaintAnalyzer {
    /// Sin map: which data is tainted
    taint_map: HashMap<Symbol, TaintLevel>,
}

impl TaintAnalyzer {
    /// Track taint propagation through function calls
    pub fn propagate_taint(&mut self, call: &FunctionCall) {
        for arg in &call.arguments {
            if self.is_tainted(arg) {
                // Sin spreads: if input tainted, output tainted
                self.taint_map.insert(call.return_value, TaintLevel::High);
            }
        }
    }
}
```

### 3.2 Syntax Extensions

```sanskrit
# Vaitarani security boundary markers

# Mark data as untrusted (from external source)
bāhya-dattā-apraviśvasta: Sūtra-vaitarani = http-prāpti(url);
#                                  ^^^^^^^^^^ Crosses Vaitarani

# COMPILER ERROR: Attempting to use without purification
yad bāhya-dattā == "admin" → {  # ERROR: Vaitarani violation
    # Cannot use tainted data in security-sensitive comparison
}

# CORRECT: Apply śuddhi-kri (purification)
śuddha-dattā: Sūtra-a = śuddhi-kri-sql(bāhya-dattā-apraviśvasta);
#                       ^^^^^^^^^^^^^ Sanitizer function
yad śuddha-dattā == "admin" → {  # OK: purified data
    praveśa-anumati();
}

# Define purification function
kāryakrama-śuddhi śuddhi-kri-sql(
    apraviśvasta: Sūtra-vaitarani  # Untrusted input
) -> Phala<Sūtra-praviśvasta, Truṭi> {  # Trusted output
    # Remove SQL injection characters
    śuddha = apraviśvasta.replace("'", "''");
    śuddha = śuddha.replace(";", "");

    yad valid_sql_identifier(śuddha) → {
        phera Saphala(śuddha);  # Successfully crossed Vaitarani
    } anyathā → {
        phera Viphala(Truṭi("Cannot purify: still tainted"));
    }
}
```

---

## PART 4: PRETA STATE (Resource Leak Detection)

### 4.1 Hungry Ghost Detection

**File: `compiler/garuda/preta/hungry_ghost.rs`**

```rust
/// Preta - Hungry ghost (allocated but never freed = unfulfilled desire)
pub struct PretaDetector {
    /// Track all allocations
    allocations: HashMap<Symbol, AllocationSite>,

    /// Track all frees
    frees: HashSet<Symbol>,
}

impl PretaDetector {
    /// Detect Preta state (memory leak)
    pub fn detect_hungry_ghosts(&self, code: &AST) -> Vec<PretaViolation> {
        let mut pretas = Vec::new();

        for (symbol, alloc_site) in &self.allocations {
            if !self.frees.contains(symbol) {
                // Allocated but never freed = Preta state
                pretas.push(PretaViolation {
                    naraka: Naraka::Suchimukha,  # Needle torture (leak)
                    symbol: symbol.clone(),
                    allocated_at: alloc_site.span,
                    never_freed: true,
                    message: format!(
                        "Object '{}' trapped in Preta state: \
                         allocated but never freed. \
                         Add mukta() to liberate.",
                        symbol.name()
                    ),
                });
            }
        }

        pretas
    }

    /// Suggest liberation (how to fix leak)
    pub fn suggest_liberation(&self, preta: &PretaViolation) -> String {
        format!(
            "Add at line {}: mukta({});  // Liberate from Preta state",
            preta.allocated_at.line + 10,  // Suggest after usage
            preta.symbol.name()
        )
    }
}
```

### 4.2 Syntax Extensions

```sanskrit
# Preta detection warnings

# This code creates a Preta (hungry ghost)
kāryakrama preta-nirmāṇa() {
    dattā-h = sthāna-āyojana(1024);  # Allocated
    prakriyā(dattā-h);
    # COMPILER WARNING: Preta state detected
    # Object 'dattā' allocated but never freed
    # Add: mukta(dattā-h);
}

# CORRECT: Liberate from Preta state
kāryakrama mokṣa-prāpti() {
    dattā-h = sthāna-āyojana(1024);
    prakriyā(dattā-h);
    mukta(dattā-h);  # Liberation! No longer Preta
}

# Automatic liberation with linear types
kāryakrama svacalita-mokṣa() {
    dattā-l^1 = nirmā^1(Bufara);  # Linear type
    prakriyā(dattā);
    # Automatic mukta() at scope end - no Preta possible
}
```

---

## PART 5: CHITRAGUPTA AUDIT TRAIL

### 5.1 Complete Record Keeping

**File: `compiler/garuda/chitragupta/records.rs`**

```rust
/// Chitragupta - Keeper of records (audit trail)
pub struct ChitraguptaRecords {
    /// Complete build history
    karma_ledger: Vec<KarmaRecord>,
