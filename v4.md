# Jagannath v3.0 Patch Specification
## Hindu Philosophy Integration Layer

**Version:** 3.0.0-philosophy
**Date:** December 26, 2024
**Patch Type:** Major Feature Addition
**Dependencies:** Requires v2.0 (Assembly Backend)
**Status:** Implementation Ready

---

## PATCH OVERVIEW

This patch adds a complete **Hindu philosophy layer** on top of the existing Jagannath compiler (v1.0 Sanskrit morphology + v2.0 Assembly backend), implementing:

1. **Nyāya Logic System** - 4-pramāṇa type inference
2. **Sāṃkhya Tattva Pipeline** - 25-stage compilation hierarchy
3. **Advaita Memory Model** - Unified heap with type overlays
4. **Pancha Kosha Memory** - 5-tier memory hierarchy
5. **Guṇa Optimization** - 3-mode compilation profiles
6. **Kāla Time Budgets** - Compile-time vs runtime prioritization
7. **Karma Dependency** - Causal dependency tracking

**Expected Performance Gain:** 60-90% over v2.0 baseline
**New Code:** ~35,000 lines Rust + ~5,000 lines Jagannath stdlib

---

## FILE STRUCTURE (NEW FILES ONLY)

```
jagannath/
├── compiler/
│   ├── philosophy/                    # NEW MODULE (v3.0)
│   │   ├── mod.rs                     # Philosophy integration entry
│   │   │
│   │   ├── nyaya/                     # Nyāya logic system
│   │   │   ├── mod.rs
│   │   │   ├── pramana.rs            # 4 pramāṇa definitions
│   │   │   ├── pratyaksha.rs         # Direct perception (explicit types)
│   │   │   ├── anumana.rs            # Inference engine
│   │   │   ├── upamana.rs            # Pattern matching
│   │   │   └── shabda.rs             # Contract/documentation validation
│   │   │
│   │   ├── samkhya/                   # Sāṃkhya 25 tattvas
│   │   │   ├── mod.rs
│   │   │   ├── tattvas.rs            # 25 tattva definitions
│   │   │   ├── purusha.rs            # Level 25 - Source intent
│   │   │   ├── prakriti.rs           # Level 24 - AST potential
│   │   │   ├── buddhi.rs             # Level 23 - Semantic analysis
│   │   │   ├── ahamkara.rs           # Level 22 - Symbol table
│   │   │   ├── manas.rs              # Level 21 - IR generation
│   │   │   ├── indriyas.rs           # Levels 20-11 - I/O faculties
│   │   │   ├── tanmatras.rs          # Levels 10-6 - Subtle elements
│   │   │   └── mahabhutas.rs         # Levels 5-1 - Gross elements
│   │   │
│   │   ├── advaita/                   # Advaita non-duality
│   │   │   ├── mod.rs
│   │   │   ├── brahman_memory.rs     # Unified memory allocator
│   │   │   ├── maya_overlay.rs       # Type system as illusion
│   │   │   └── atman_optimization.rs # Identity-based optimizations
│   │   │
│   │   ├── pancha_kosha/              # 5 bodies memory model
│   │   │   ├── mod.rs
│   │   │   ├── annamaya.rs           # Physical - Register/L1
│   │   │   ├── pranamaya.rs          # Vital - L2/L3 cache
│   │   │   ├── manomaya.rs           # Mental - RAM
│   │   │   ├── vijnanamaya.rs        # Wisdom - Disk/persistent
│   │   │   └── anandamaya.rs         # Bliss - Network/distributed
│   │   │
│   │   ├── guna/                      # 3 guṇa optimization modes
│   │   │   ├── mod.rs
│   │   │   ├── sattva.rs             # Purity - correctness-first
│   │   │   ├── rajas.rs              # Activity - speed-first
│   │   │   └── tamas.rs              # Inertia - memory-first
│   │   │
│   │   ├── kala/                      # Time dilation/budgets
│   │   │   ├── mod.rs
│   │   │   ├── brahma_time.rs        # Compile-time (infinite budget)
│   │   │   ├── manushya_time.rs      # Runtime (normal)
│   │   │   └── kshana_time.rs        # Critical path (instant)
│   │   │
│   │   └── karma/                     # Causation/dependency
│   │       ├── mod.rs
│   │       ├── dependency_graph.rs   # Karma chain tracking
│   │       ├── samsara.rs            # Recompilation cycles
│   │       └── moksha.rs             # Pure functions (no deps)
│   │
│   └── semantics/
│       └── philosophy_integration.rs  # Bridge to existing semantic pass
│
├── stdlib/
│   └── darshana/                      # Philosophy library (NEW)
│       ├── nyaya.jag                  # Nyāya logic utilities
│       ├── samkhya.jag                # Tattva introspection
│       ├── advaita.jag                # Memory unity helpers
│       └── yoga.jag                   # Karma tracking API
│
├── docs/
│   ├── philosophy/                    # NEW DOCUMENTATION
│   │   ├── nyaya_guide.md            # Pramāṇa type system guide
│   │   ├── samkhya_pipeline.md       # Tattva compilation stages
│   │   ├── advaita_memory.md         # Unified heap model
│   │   ├── pancha_kosha.md           # 5-tier memory guide
│   │   └── hindu_concepts.md         # Complete philosophy reference
│   │
│   └── migration/
│       └── v2_to_v3_upgrade.md       # Migration guide
│
└── examples/
    └── philosophy/                    # NEW EXAMPLES
        ├── nyaya_inference.jag        # Type inference demo
        ├── samkhya_stages.jag         # Compilation stage demo
        ├── advaita_polymorphism.jag   # Unified memory demo
        ├── kosha_allocation.jag       # 5-tier memory demo
        └── guna_optimization.jag      # 3-mode optimization demo
```

---

## PART 1: NYĀYA LOGIC SYSTEM

### 1.1 New Affixes for Pramāṇas

**File: `compiler/philosophy/nyaya/pramana.rs`**

```rust
/// Nyāya pramāṇa (means of valid knowledge) markers
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Pramana {
    /// Pratyakṣa - Direct perception (explicit annotation)
    Pratyaksha,   // Suffix: -pratyakṣa

    /// Anumāna - Inference (logical deduction)
    Anumana,      // Suffix: -anumāna

    /// Upamāna - Comparison (pattern matching)
    Upamana,      // Suffix: -upamāna

    /// Śabda - Testimony (documentation/contract)
    Shabda,       // Suffix: -śabda
}

/// Map pramāṇa to certainty level
impl Pramana {
    pub fn certainty(&self) -> f32 {
        match self {
            Pramana::Pratyaksha => 1.0,   // 100% certain (explicit)
            Pramana::Anumana => 0.95,     // 95% certain (inferred)
            Pramana::Upamana => 0.85,     // 85% certain (analogous)
            Pramana::Shabda => 0.90,      // 90% certain (documented)
        }
    }
}
```

### 1.2 Syntax Extensions

**NEW: Pramāṇa Type Annotations**

```sanskrit
# 1. PRATYAKṢA (Explicit - highest certainty)
saṅkhyā-pratyakṣa-k: t32 = 42;
# Compiler: Direct observation, 100% certain

# 2. ANUMĀNA (Inferred - logical deduction)
saṅkhyā-anumāna-k = 42;
# Compiler infers: "Must be t32 because literal 42 fits t32"

# 3. UPAMĀNA (Pattern match - by analogy)
kāryakrama yojana-upamāna<T>(x: T, y: T) -> T {
    # T inferred by upamāna: both params must match
    phera x + y;
}

# 4. ŚABDA (Contract - documentation authority)
kāryakrama-śabda gaṇana(
    sūci: Sūci<t32>-b
) -> t64-k
yatra sūci.dairghya > 0,    # Precondition (śabda pramāṇa)
      phala >= 0             # Postcondition (śabda pramāṇa)
{
    soma-k: t64 = 0;
    cala x : sūci → { soma += x; }
    phera soma;
}
```

### 1.3 Implementation

**File: `compiler/philosophy/nyaya/anumana.rs`**

```rust
/// Anumāna inference engine
pub struct AnumanaInference {
    /// Known facts (hetu - evidence)
    facts: Vec<Fact>,

    /// Inference rules (vyāpti - invariable relation)
    rules: Vec<InferenceRule>,
}

impl AnumanaInference {
    /// Perform anumāna (inference) to determine type
    pub fn infer_type(&self, expr: &Expr) -> Option<Type> {
        // Classic Nyāya inference (5-step syllogism):
        // 1. Pratijñā (Proposition): "x has type T"
        // 2. Hetu (Reason): "because x is used as T"
        // 3. Udāharaṇa (Example): "like other T values"
        // 4. Upanaya (Application): "x is similar"
        // 5. Nigamana (Conclusion): "therefore x: T"

        for rule in &self.rules {
            if let Some(hetu) = self.find_evidence(expr) {
                if rule.applies(hetu) {
                    return Some(rule.conclude_type());
                }
            }
        }
        None
    }
}

/// Vyāpti - Universal relation (like "where smoke, there fire")
pub struct InferenceRule {
    pub condition: Box<dyn Fn(&Expr) -> bool>,
    pub conclusion: Type,
    pub vyapti: String,  // The universal relation
}
```

### 1.4 Error Messages (NEW)

```
Error: Cannot determine type for `x`

Attempted pramāṇas (means of knowledge):
  × Pratyakṣa (Direct): No explicit type annotation
  × Anumāna (Inference): Insufficient evidence at line 42
    Evidence found: x used in arithmetic
    Cannot conclude: Could be t32, t64, or f32
  × Upamāna (Analogy): No matching pattern
    Similar expressions: None in scope
  × Śabda (Testimony): No documentation contract

Suggestion: Add explicit type (pratyakṣa pramāṇa)
  Help: x-pratyakṣa-k: t32 = ...
```

---

## PART 2: SĀṂKHYA TATTVA PIPELINE

### 2.1 25 Tattva Definitions

**File: `compiler/philosophy/samkhya/tattvas.rs`**

```rust
/// Sāṃkhya tattva - Principle of manifestation
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Tattva {
    // Level 25-24: Unmanifest
    Purusha = 25,        // Pure consciousness (source code intent)
    Prakriti = 24,       // Primordial matter (AST potential)

    // Level 23-21: Cognitive faculties
    Buddhi = 23,         // Intellect (semantic analysis)
    Ahamkara = 22,       // Ego-sense (symbol table/naming)
    Manas = 21,          // Mind (IR generation)

    // Level 20-16: Sensory faculties (Jñānendriyas)
    Shrotra = 20,        // Hearing (lexical analysis)
    Tvak = 19,           // Touch (syntax validation)
    Chakshu = 18,        // Sight (AST construction)
    Rasana = 17,         // Taste (semantic checking)
    Ghrana = 16,         // Smell (pattern recognition)

    // Level 15-11: Action faculties (Karmendriyas)
    Vak = 15,            // Speech (code emission)
    Pani = 14,           // Hands (manipulation)
    Pada = 13,           // Feet (traversal)
    Payu = 12,           // Excretion (cleanup)
    Upastha = 11,        // Generation (output)

    // Level 10-6: Subtle elements (Tanmātras)
    Shabda = 10,         // Sound essence (tokens)
    Sparsha = 9,         // Touch essence (syntax)
    Rupa = 8,            // Form essence (structure)
    Rasa = 7,            // Taste essence (semantics)
    Gandha = 6,          // Smell essence (patterns)

    // Level 5-1: Gross elements (Mahābhūtas)
    Akasha = 5,          // Space (memory layout)
    Vayu = 4,            // Air (control flow)
    Tejas = 3,           // Fire (computation)
    Apas = 2,            // Water (data flow)
    Prithivi = 1,        // Earth (machine code - final)
}

impl Tattva {
    /// Get cache key for this tattva stage
    pub fn cache_key(&self) -> String {
        format!("tattva_{:02}", *self as u8)
    }

    /// Can we restart compilation from this tattva?
    pub fn is_cacheable(&self) -> bool {
        match self {
            Tattva::Buddhi | Tattva::Manas | Tattva::Akasha => true,
            _ => false,
        }
    }
}
```

### 2.2 Syntax Extensions

```sanskrit
# Tattva-level compilation control

# Compile to specific tattva level only
saṃkalana-tattva(source.jag, tattva: Buddhi) {
    # Stop at semantic analysis, cache result
}

# Resume from cached tattva
saṃkalana-punah(cache: Buddhi-cache) -> Prithivi {
    # Resume from IR, skip earlier stages
}

# Introspect compilation stage
tattva-darśana-k() {
    yad saṃkalana-sthiti {
        | Purusha → mudraṇa("Parsing source"),
        | Buddhi → mudraṇa("Analyzing semantics"),
        | Prithivi → mudraṇa("Generating assembly")
    }
}
```

### 2.3 Implementation

**File: `compiler/philosophy/samkhya/mod.rs`**

```rust
/// Sāṃkhya-based compilation pipeline
pub struct SamkhyaCompiler {
    /// Current tattva (stage of manifestation)
    current_tattva: Tattva,

    /// Cached intermediate results (saṃskāra - impressions)
    tattva_cache: HashMap<Tattva, CachedResult>,

    /// Evolution path (prakṛti vikāra)
    evolution_path: Vec<Tattva>,
}

impl SamkhyaCompiler {
    /// Evolve from puruṣa (source) to pṛthivī (machine code)
    pub fn evolve(&mut self, source: SourceCode) -> MachineCode {
        let mut state = CompilationState::Purusha(source);

        for tattva in Self::tattva_sequence() {
            // Check cache (saṃskāra - past impressions)
            if let Some(cached) = self.tattva_cache.get(&tattva) {
                if cached.is_valid() {
                    state = cached.state.clone();
                    continue;
                }
            }

            // Evolve to next tattva (vikāra - transformation)
            state = self.transform(state, tattva);

            // Cache if tattva is stable
            if tattva.is_cacheable() {
                self.tattva_cache.insert(tattva, CachedResult {
                    state: state.clone(),
                    timestamp: SystemTime::now(),
                });
            }
        }

        self.extract_machine_code(state)
    }

    /// 25-stage tattva sequence
    fn tattva_sequence() -> Vec<Tattva> {
        (1..=25).rev().map(|n| Tattva::from_level(n)).collect()
    }
}
```

---

## PART 3: ADVAITA UNIFIED MEMORY

### 3.1 New Memory Model

**File: `compiler/philosophy/advaita/brahman_memory.rs`**

```rust
/// Advaita principle: All memory is manifestation of Brahman
/// Types are māyā (illusion) - overlays on unified reality
pub struct BrahmanHeap {
    /// The one reality (Brahman) - unified memory pool
    brahman: Vec<u8>,

    /// Nāma-rūpa (name-form) - illusory type distinctions
    nama_rupa_table: HashMap<TypeId, NamaRupa>,

    /// Witness (sākṣī) - metadata for allocations
    witness: AllocationRegistry,
}

/// Nāma-rūpa - Name and form (apparent distinction)
pub struct NamaRupa {
    pub name: String,      // Type name (nāma)
    pub layout: Layout,    // Memory form (rūpa)
    pub is_maya: bool,     // Is this a projected type?
}

impl BrahmanHeap {
    /// Allocate - all allocations from same Brahman
    pub fn allocate<T>(&mut self, value: T) -> BrahmanPtr<T> {
        let offset = self.brahman.len();
        self.brahman.extend_from_slice(to_bytes(&value));

        BrahmanPtr {
            brahman_offset: offset,
            type_overlay: PhantomData,  // Type is māyā
        }
    }

    /// Advaita optimization: recognize underlying unity
    pub fn unify_compatible_types(&mut self) {
        // If two types have identical layout, treat as same reality
        for (ty1, layout1) in &self.nama_rupa_table {
            for (ty2, layout2) in &self.nama_rupa_table {
                if ty1 != ty2 && layout1.layout == layout2.layout {
                    // Mark as unified (same Brahman, different māyā)
                    self.mark_unified(ty1, ty2);
                }
            }
        }
    }
}

/// Pointer with type overlay (pratibhāsa - apparent form)
pub struct BrahmanPtr<T> {
    brahman_offset: usize,        // Position in unified reality
    type_overlay: PhantomData<T>, // Illusory type distinction
}

impl<T> BrahmanPtr<T> {
    /// Advaita transmutation: change māyā (type view) without changing Brahman
    pub fn transmute_view<U>(self) -> BrahmanPtr<U>
    where
        Layout<T>: CompatibleWith<Layout<U>>
    {
        BrahmanPtr {
            brahman_offset: self.brahman_offset,  // Same reality
            type_overlay: PhantomData,             // Different illusion
        }
    }
}
```

### 3.2 Syntax Extensions

```sanskrit
# Advaita memory annotations

# Vyavahārika level (empirical - appears distinct)
prakāra Upayoktṛ-vyavahārika-p = {
    id: t64-k, nāma: Sūtra-a
}

# Paramārthika level (absolute - compiler sees unity)
prakāra Grāhaka-paramārthika-p = {
    id: t64-k, viṣayavastu: Sūtra-a
}

# Advaita optimization hint
kāryakrama-advaita prakriyā(x: Upayoktṛ-b, y: Grāhaka-b) {
    # Compiler recognizes: same layout = same Brahman
    # Can optimize as single code path
    yad x.id == y.id → {
        # Zero-cost comparison (same reality)
    }
}

# Explicit transmutation (safe type view change)
māyā-pariṇāma<T, U>(ptr: BrahmanPtr<T>) -> BrahmanPtr<U>
yatra Layout<T> == Layout<U>  # Compiler verifies compatibility
{
    # Change type view without copying data
    phera ptr as BrahmanPtr<U>;
}
```

---

## PART 4: PANCHA KOSHA MEMORY TIERS

### 4.1 5-Body Memory Hierarchy

**File: `compiler/philosophy/pancha_kosha/mod.rs`**

```rust
/// Pancha Kosha - 5 sheaths/bodies memory model
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Kosha {
    /// Annamaya - Physical body (most gross)
    Annamaya = 1,    // Register/L1 cache - fastest

    /// Prāṇamaya - Vital/energy body
    Pranamaya = 2,   // L2/L3 cache - fast

    /// Manomaya - Mental body
    Manomaya = 3,    // RAM - working memory

    /// Vijñānamaya - Wisdom body
    Vijnanamaya = 4, // Disk - persistent storage

    /// Ānandamaya - Bliss body (most subtle)
    Anandamaya = 5,  // Network/cloud - boundless
}

impl Kosha {
    /// Get optimal memory location for this kosha
    pub fn memory_location(&self) -> MemoryLocation {
        match self {
            Kosha::Annamaya => MemoryLocation::Register,
            Kosha::Pranamaya => MemoryLocation::L2Cache,
            Kosha::Manomaya => MemoryLocation::RAM,
            Kosha::Vijnanamaya => MemoryLocation::Disk,
            Kosha::Anandamaya => MemoryLocation::Network,
        }
    }

    /// Access latency for this kosha
    pub fn latency_cycles(&self) -> u64 {
        match self {
            Kosha::Annamaya => 1,       // 1 cycle (register)
            Kosha::Pranamaya => 10,     // 10 cycles (L2)
            Kosha::Manomaya => 100,     // 100 cycles (RAM)
            Kosha::Vijnanamaya => 10_000_000, // 10M cycles (disk)
            Kosha::Anandamaya => 100_000_000,  // 100M cycles (network)
        }
    }
}

/// Kosha-aware allocation strategy
pub struct KoshaAllocator {
    /// Heat map: track access frequency
    access_counts: HashMap<Symbol, u64>,

    /// Current placement
    placements: HashMap<Symbol, Kosha>,
}

impl KoshaAllocator {
    /// Migrate data between koshas based on access patterns
    pub fn optimize_placement(&mut self) {
        for (symbol, count) in &self.access_counts {
            let current_kosha = self.placements[symbol];
            let optimal_kosha = self.infer_kosha(*count);

            if optimal_kosha < current_kosha {
                // Move to inner kosha (faster access)
                self.migrate(symbol, optimal_kosha);
            } else if optimal_kosha > current_kosha {
                // Move to outer kosha (free up fast memory)
                self.migrate(symbol, optimal_kosha);
            }
        }
    }

    fn infer_kosha(&self, access_count: u64) -> Kosha {
        match access_count {
            1000.. => Kosha::Annamaya,      // Very hot → register
            100..=999 => Kosha::Pranamaya,  // Hot → cache
            10..=99 => Kosha::Manomaya,     // Warm → RAM
            2..=9 => Kosha::Vijnanamaya,    // Cold → disk
            0..=1 => Kosha::Anandamaya,     // Frozen → network
        }
    }
}
```

### 4.2 Syntax Extensions

```sanskrit
# Pancha Kosha memory tier annotations

# Annamaya (physical - register/L1)
gaṇaka-anna-k: t64 = 0;
cala i : 0..1000000 → {
    gaṇaka-anna += i;  # Hot loop counter in register
}

# Prāṇamaya (vital - L2/L3 cache)
bufara-prana-k: [4096] = śūnya;
# Cache-aligned buffer for hot data

# Manomaya (mental - RAM)
upayoktṛ-manas-l^1 = nirmā^1(Upayoktṛ { ... });
# User object in working memory

# Vijñānamaya (wisdom - disk/persistent)
dattakoṣa-vijnana-h = Dattakoṣa-kholana("/data/users.db");
# Database on persistent storage

# Ānandamaya (bliss - network/cloud)
sevā-ananda-g-sūtra = Http-sevā-prārambha("0.0.0.0:8080");
# Network service (boundless, distributed)

# Automatic migration hint
sañcaya-kosha-svachalita-k = [1000];
# Compiler migrates between koshas based on access pattern
```

---

## PART 5: GUṆA OPTIMIZATION MODES

### 5.1 Three Quality Profiles

**File: `compiler/philosophy/guna/mod.rs`**

```rust
/// Guṇa - Quality/mode of optimization
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Guna {
    /// Sattva - Purity, goodness
    Sattva,  // Correctness-first, formal verification

    /// Rajas - Passion, activity
    Rajas,   // Speed-first, aggressive optimization

    /// Tamas - Darkness, inertia
    Tamas,   // Memory-first, minimal resource use
}

impl Guna {
    /// Optimization strategy for this guṇa
    pub fn optimization_strategy(&self) -> OptimizationStrategy {
        match self {
            Guna::Sattva => OptimizationStrategy {
                inline_threshold: 50,      // Conservative inlining
                unroll_loops: false,       // Preserve structure
                bounds_checks: true,       // Always verify
                overflow_checks: true,     // Safety first
                assertions: true,          // Keep all assertions
                optimization_level: 1,     // Moderate optimization
            },

            Guna::Rajas => OptimizationStrategy {
                inline_threshold: 1000,    // Aggressive inlining
                unroll_loops: true,        // Unroll everything
                bounds_checks: false,      // Assume valid
                overflow_checks: false,    // Trust programmer
                assertions: false,         // Remove all asserts
                optimization_level: 3,     // Maximum optimization
            },

            Guna::Tamas => OptimizationStrategy {
                inline_threshold: 10,      // Minimal inlining
                unroll_loops: false,       // No unrolling
                bounds_checks: true,       // Safety retained
                overflow_checks: true,     // Errors detected
                assertions: true,          // Debugging enabled
                optimization_level: 0,     // Size optimization
            },
        }
    }
}
```

### 5.2 Syntax Extensions

```sanskrit
# Guṇa-based optimization markers

# SATTVA (correctness-first)
kāryakrama-sattva saṃkalana-surakṣita(a: t32-k, b: t32-k) -> t32-k {
    # Verified correct, may be slower
    # Overflow checks, bounds checks, assertions
    phera a + b;
}

# RAJAS (speed-first)
kāryakrama-rajas saṃkalana-druta(a: t32-k, b: t32-k) -> t32-k {
    # Maximum speed, assumes valid input
    # No checks, aggressive inline, loop unrolling
    phera a + b;
}

# TAMAS (memory-first)
kāryakrama-tamas saṃkalana-laghu(a: t32-k, b: t32-k) -> t32-k {
    # Minimum memory footprint
    # Reuse registers, no stack allocation, size-optimized
    phera a + b;
}

# Mixed guṇa per function
kāryakrama prakriyā-miśra(
    x: t32-sattva-k,  # This param needs safety
    y: t32-rajas-k    # This param needs speed
) -> t32-tamas-l {   # Return needs small size
    phera (x + y);
}
```

---

## PART 6: KĀLA TIME BUDGETS

### 6.1 Time Dilation System

**File: `compiler/philosophy/kala/mod.rs`**

```rust
/// Kāla - Time scale (Hindu cosmological time)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Kala {
    /// Brahma-kāla - Day of Brahma (eons)
    Brahma,  // Compile-time (infinite budget)

    /// Manuṣya-kāla - Human time (years)
    Manushya, // Runtime (normal)

    /// Kṣaṇa-kāla -
